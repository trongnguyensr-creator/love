<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pháo Hoa</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: system-ui, sans-serif;
            color: #fff;
        }
        #canvas {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
        }
        #startBtn {
            position: relative;
            z-index: 10;
            padding: 22px 56px;
            font-size: 32px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.95);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.15), 
                rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: 
                0 10px 35px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            letter-spacing: 1px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            transform: translateY(0);
            animation: float 3s ease-in-out infinite;
            overflow: hidden;
        }
        
        #startBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.2), 
                rgba(255, 255, 255, 0.1));
            border-radius: 20px;
            z-index: -1;
        }
        
        #startBtn::after {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            bottom: 1px;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.1), 
                rgba(255, 255, 255, 0.05));
            border-radius: 19px;
            z-index: -1;
        }
        
        #startBtn:active {
            transform: scale(0.85) translateY(5px);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.1), 
                rgba(255, 255, 255, 0.02));
            box-shadow: 
                0 5px 15px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            opacity: 0.7;
            transition: all 0.2s ease-out;
        }
        
        #startBtn.clicked {
            animation: fadeInOut 0.8s ease-out forwards;
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
                box-shadow: 
                    0 10px 35px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            }
            50% {
                transform: translateY(-10px);
                box-shadow: 
                    0 15px 40px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.25),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.35);
            }
        }
        
        @keyframes fadeInOut {
            0% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
            30% {
                transform: scale(1.1) translateY(-20px);
                opacity: 0.8;
            }
            100% {
                transform: scale(0) translateY(100px);
                opacity: 0;
                visibility: hidden;
            }
        }
        
        .btn-text {
            position: relative;
            z-index: 1;
            background: linear-gradient(45deg, 
                rgba(255, 255, 255, 0.95), 
                rgba(255, 255, 255, 0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body>
    <button id="startBtn">
        <span class="btn-text">BẮT ĐẦU</span>
    </button>
    <canvas id="canvas"></canvas>

    <script>
        // CẤU HÌNH ÂM THANH (CHỈ TRẦM)
        const SOUND_CONFIG = {
            masterVolume: 1.3,
            baseInterval: 1600,
            intervalVariation: 1000,
            fadeInTime: 0.2,
            fadeOutTime: 1.2,
            frequencyBlend: {
                min: 30,
                max: 80,
                glideTime: 0.6
            },
            layers: {
                sub: { weight: 1.0, freqRange: [30, 70] },
                deep: { weight: 0.7, freqRange: [20, 45] },
                rumble: { weight: 0.4, freqRange: [100, 300] }
            }
        };

        // CẤU HÌNH PHÁO HOA - ĐIỀU CHỈNH VỚI PHÁO LỚN
        const FIREWORK_CONFIG = {
            maxParticlesPerExplosion: 70,
            maxIntensity: 2.5,
            explosionIntervalMin: 1400,
            explosionIntervalMax: 2200,
            targetFPS: 60,
            maxActiveParticles: 1200, // Tăng lên để chứa pháo lớn
            particleSizeMultiplier: 0.5,
            rocketSpeedMultiplier: 0.8,
            explosionSpeedMultiplier: 0.7,
            
            // CẤU HÌNH PHÂN LOẠI PHÁO BÔNG
            // 45% pháo lớn (gần) - 33% lớn hơn pháo thường
            // 30% pháo thường gần - 25% pháo xa
            fireworkTypes: {
                largeNear: {
                    probability: 0.45, // 45% pháo lớn gần
                    sizeMultiplier: 1.33, // Lớn hơn 33%
                    minHeight: 0.15,
                    maxHeight: 0.35,
                    speedMultiplier: 1.15,
                    glowIntensity: 1.8,
                    explosionRadius: 1.4,
                    particleCountMultiplier: 1.5
                },
                normalNear: {
                    probability: 0.30, // 30% pháo thường gần
                    sizeMultiplier: 1.0,
                    minHeight: 0.20,
                    maxHeight: 0.45,
                    speedMultiplier: 1.1,
                    glowIntensity: 1.3,
                    explosionRadius: 1.0,
                    particleCountMultiplier: 1.0
                },
                far: {
                    probability: 0.25, // 25% pháo xa
                    sizeMultiplier: 0.8,
                    minHeight: 0.55,
                    maxHeight: 0.85,
                    speedMultiplier: 0.9,
                    glowIntensity: 1.0,
                    explosionRadius: 0.9,
                    particleCountMultiplier: 0.8
                }
            }
        };

        // ĐƯỜNG DẪN FILE NHẠC
        const MUSIC_FILE = 'phaobong.mp3';

        let canvas, ctx, audioCtx, masterGain, backgroundMusic;
        let particles = [];
        let glowEffects = []; // Mảng chứa hiệu ứng sáng khi nổ
        let particlePoolSize = FIREWORK_CONFIG.maxParticlesPerExplosion * 30; // Tăng pool size
        let lastTime = 0, startTime = 0;
        let isRunning = false;
        let nextExplosionTime = 0;
        let nextSoundTime = 0;
        let soundSequence = 0;
        let activeSounds = new Set();
        let isMusicLoaded = false;
        let isMusicPlaying = false;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // ====================== HỆ THỐNG HIỆU ỨNG SÁNG ======================
        function createGlowEffect(x, y, type = 'largeNear') {
            const types = FIREWORK_CONFIG.fireworkTypes;
            const config = types[type];
            
            glowEffects.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 80 * config.glowIntensity,
                life: 0,
                maxLife: 40 + Math.random() * 20,
                color: `hsl(${Math.random() * 360}, 100%, 80%)`,
                intensity: config.glowIntensity,
                pulseSpeed: 0.1 + Math.random() * 0.15
            });
        }

        function updateGlowEffects(delta) {
            for (let i = glowEffects.length - 1; i >= 0; i--) {
                const glow = glowEffects[i];
                glow.life += delta;
                
                if (glow.life >= glow.maxLife) {
                    glowEffects.splice(i, 1);
                    continue;
                }
                
                const progress = glow.life / glow.maxLife;
                // Hiệu ứng mở rộng rồi co lại
                const pulse = Math.sin(progress * Math.PI * 2 * glow.pulseSpeed);
                glow.radius = glow.maxRadius * (1 - progress * 0.7) * (1 + pulse * 0.2);
            }
        }

        function renderGlowEffects() {
            for (const glow of glowEffects) {
                const progress = glow.life / glow.maxLife;
                const alpha = (1 - progress) * 0.6 * glow.intensity;
                
                // Vẽ glow core
                const gradient = ctx.createRadialGradient(
                    glow.x, glow.y, 0,
                    glow.x, glow.y, glow.radius
                );
                
                gradient.addColorStop(0, glow.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla'));
                gradient.addColorStop(0.5, glow.color.replace(')', `, ${alpha * 0.5})`).replace('hsl', 'hsla'));
                gradient.addColorStop(1, glow.color.replace(')', `, 0)`).replace('hsl', 'hsla'));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(glow.x, glow.y, glow.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Vẽ ánh sáng tỏa ra
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI) / 4;
                    const length = glow.radius * 1.5;
                    const x2 = glow.x + Math.cos(angle) * length;
                    const y2 = glow.y + Math.sin(angle) * length;
                    
                    const lineGradient = ctx.createLinearGradient(glow.x, glow.y, x2, y2);
                    lineGradient.addColorStop(0, glow.color.replace(')', `, ${alpha * 0.8})`).replace('hsl', 'hsla'));
                    lineGradient.addColorStop(1, glow.color.replace(')', `, 0)`).replace('hsl', 'hsla'));
                    
                    ctx.strokeStyle = lineGradient;
                    ctx.lineWidth = 3 + Math.random() * 4;
                    ctx.beginPath();
                    ctx.moveTo(glow.x, glow.y);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // ====================== HỆ THỐNG NHẠC NỀN ======================
        function initBackgroundMusic() {
            return new Promise((resolve, reject) => {
                try {
                    backgroundMusic = new Audio();
                    backgroundMusic.src = MUSIC_FILE;
                    backgroundMusic.loop = true;
                    backgroundMusic.volume = 0.7;
                    backgroundMusic.preload = 'auto';
                    
                    backgroundMusic.addEventListener('loadeddata', () => {
                        isMusicLoaded = true;
                        resolve(true);
                    });
                    
                    backgroundMusic.addEventListener('error', (e) => {
                        console.error("❌ Lỗi tải nhạc:", e);
                        reject(new Error("Không thể tải nhạc nền"));
                    });
                    
                    backgroundMusic.load();
                    
                } catch (e) {
                    console.error("❌ Lỗi khởi tạo nhạc:", e);
                    reject(e);
                }
            });
        }

        function playBackgroundMusic() {
            if (!backgroundMusic || !isMusicLoaded) {
                return false;
            }
            
            try {
                backgroundMusic.volume = 0;
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        fadeMusicVolume(0, 0.7, 1.5);
                    }).catch(error => {
                        console.error("❌ Lỗi phát nhạc:", error);
                    });
                }
                
                return true;
            } catch (e) {
                console.error("❌ Lỗi khi phát nhạc:", e);
                return false;
            }
        }

        function fadeMusicVolume(from, to, duration) {
            if (!backgroundMusic) return;
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            function updateVolume() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / (duration * 1000), 1);
                const currentVolume = from + (to - from) * progress;
                
                backgroundMusic.volume = Math.max(0, Math.min(1, currentVolume));
                
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }

        function pauseBackgroundMusic() {
            if (backgroundMusic && isMusicPlaying) {
                backgroundMusic.pause();
                isMusicPlaying = false;
            }
        }

        // ====================== HỆ THỐNG ÂM THANH (CHỈ TRẦM) ======================
        function initAudioSystem() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioCtx.createGain();
                masterGain.gain.value = SOUND_CONFIG.masterVolume;
                
                const compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -20;
                compressor.knee.value = 30;
                compressor.ratio.value = 6;
                compressor.attack.value = 0.03;
                compressor.release.value = 0.3;
                
                const lowShelf = audioCtx.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 150;
                lowShelf.gain.value = 8;
                
                masterGain.connect(lowShelf).connect(compressor).connect(audioCtx.destination);
                
                return true;
            } catch (e) {
                console.log("Audio không được hỗ trợ");
                return false;
            }
        }

        function createBassSound(frequency, type = 'sine', duration = 1.0, volume = 1.0) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.value = frequency;
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + SOUND_CONFIG.fadeInTime);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            const soundId = Symbol();
            activeSounds.add(soundId);
            
            setTimeout(() => {
                activeSounds.delete(soundId);
            }, duration * 1000);
            
            return soundId;
        }

        function createBassGlide(startFreq, endFreq, type = 'sine', duration = 1.2, volume = 0.9) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(endFreq, now + SOUND_CONFIG.frequencyBlend.glideTime);
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            return Symbol();
        }

        function createRumbleSound(duration = 0.8, baseFreq = 120, volume = 0.5) {
            const now = audioCtx.currentTime;
            
            for (let i = 0; i < 3; i++) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = baseFreq + (i * 15);
                
                gain.gain.setValueAtTime(0.001, now + (i * 0.05));
                gain.gain.exponentialRampToValueAtTime(volume * (0.7 - i * 0.2), now + (i * 0.05) + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(gain).connect(masterGain);
                osc.start(now + (i * 0.05));
                osc.stop(now + duration);
            }
            
            return Symbol();
        }

        // ====================== CÁC BỘ ÂM THANH BASS ======================
        
        function playDeepBass(type = 'normalNear') {
            const baseFreq = type === 'largeNear' ? 40 + Math.random() * 25 : 35 + Math.random() * 20;
            const volumeMultiplier = type === 'largeNear' ? 1.4 : 1.0;
            
            createBassSound(
                baseFreq,
                'sine',
                type === 'largeNear' ? 1.6 : 1.4,
                SOUND_CONFIG.layers.sub.weight * volumeMultiplier
            );
            
            setTimeout(() => {
                createBassSound(
                    baseFreq * 0.5,
                    'sine',
                    type === 'largeNear' ? 1.8 : 1.6,
                    SOUND_CONFIG.layers.deep.weight * 0.6 * volumeMultiplier
                );
            }, 200);
            
            setTimeout(() => {
                createRumbleSound(
                    type === 'largeNear' ? 0.8 : 0.6,
                    80 + Math.random() * 40,
                    SOUND_CONFIG.layers.rumble.weight * 0.3 * volumeMultiplier
                );
            }, 150);
        }

        function playSpecialBassExplosion(type = 'normalNear', intensity = 1.0) {
            const baseFreq = type === 'largeNear' ? 45 + Math.random() * 30 : 
                           type === 'normalNear' ? 40 + Math.random() * 25 : 35 + Math.random() * 15;
            
            const duration = type === 'largeNear' ? 1.6 + intensity * 0.4 : 
                           type === 'normalNear' ? 1.4 + intensity * 0.5 : 1.2 + intensity * 0.3;
            
            const volumeMultiplier = type === 'largeNear' ? 1.8 : type === 'normalNear' ? 1.3 : 1.0;
            
            createBassGlide(
                baseFreq * (type === 'largeNear' ? 1.8 : 1.4),
                baseFreq * 0.5,
                'sine',
                duration,
                SOUND_CONFIG.layers.sub.weight * intensity * volumeMultiplier
            );
            
            setTimeout(() => {
                createBassSound(
                    baseFreq * 0.8,
                    'sine',
                    duration * 0.9,
                    SOUND_CONFIG.layers.deep.weight * intensity * (type === 'largeNear' ? 1.2 : 0.8)
                );
                
                createBassSound(
                    baseFreq * 0.6,
                    'sine',
                    duration * 1.1,
                    SOUND_CONFIG.layers.deep.weight * intensity * (type === 'largeNear' ? 1.0 : 0.6)
                );
            }, 100);
            
            setTimeout(() => {
                createRumbleSound(
                    duration * 0.8,
                    (type === 'largeNear' ? 90 : type === 'normalNear' ? 70 : 50) + Math.random() * 20,
                    SOUND_CONFIG.layers.rumble.weight * intensity * (type === 'largeNear' ? 1.1 : 0.7)
                );
            }, 180);
        }

        // ====================== HỆ THỐNG PHÁO HOA VỚI 3 LOẠI ======================
        function createParticlePool() {
            particles = [];
            for (let i = 0; i < particlePoolSize; i++) {
                particles.push({
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 0,
                    color: '#fff',
                    size: 1.0 * FIREWORK_CONFIG.particleSizeMultiplier,
                    active: false,
                    type: 'normalNear',
                    glowPower: 0,
                    initialGlow: 0
                });
            }
        }

        function getParticle() {
            for (let p of particles) {
                if (!p.active) return p;
            }
            
            let oldestParticle = null;
            let oldestLife = 0;
            for (let p of particles) {
                if (p.active) {
                    const lifeRatio = p.life / p.maxLife;
                    if (lifeRatio > oldestLife) {
                        oldestLife = lifeRatio;
                        oldestParticle = p;
                    }
                }
            }
            
            if (oldestParticle && oldestLife > 0.8) {
                oldestParticle.active = false;
                return oldestParticle;
            }
            
            return null;
        }

        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            const dpr = Math.min(window.devicePixelRatio || 1, 1.2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = `${window.innerWidth}px`;
            canvas.style.height = `${window.innerHeight}px`;
            ctx.scale(dpr, dpr);
            canvas.style.display = 'block';
        }

        function countActiveParticles() {
            let count = 0;
            for (let p of particles) {
                if (p.active) count++;
            }
            return count;
        }

        function getRandomFireworkType() {
            const rand = Math.random();
            const types = FIREWORK_CONFIG.fireworkTypes;
            let cumulative = 0;
            
            for (const [type, config] of Object.entries(types)) {
                cumulative += config.probability;
                if (rand < cumulative) {
                    return type;
                }
            }
            
            return 'normalNear'; // Fallback
        }

        function createRocket() {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles) return;

            const type = getRandomFireworkType();
            const config = FIREWORK_CONFIG.fireworkTypes[type];
            
            const x = Math.random() * window.innerWidth;
            const yStart = window.innerHeight;
            const hue = Math.random() * 360;
            const saturation = type === 'largeNear' ? 100 : type === 'normalNear' ? 95 : 90;

            const p = getParticle();
            if (p) {
                p.x = x;
                p.y = yStart;
                p.vx = (Math.random() - 0.5) * 1.2 * config.speedMultiplier;
                p.vy = - (12 + Math.random() * 6) * FIREWORK_CONFIG.rocketSpeedMultiplier * config.speedMultiplier;
                p.life = 0;
                p.maxLife = 50 + Math.random() * 20;
                p.color = `hsl(${hue}, ${saturation}%, ${type === 'largeNear' ? 85 : 70}%)`;
                p.size = (1.5 + Math.random() * 0.8) * FIREWORK_CONFIG.particleSizeMultiplier * config.sizeMultiplier;
                p.active = true;
                p.isRocket = true;
                p.type = type;
                p.trailHue = hue;
                p.glowPower = type === 'largeNear' ? 1.5 : type === 'normalNear' ? 1.2 : 1.0;
                p.initialGlow = type === 'largeNear' ? 1.0 : type === 'normalNear' ? 0.8 : 0.6;
            }

            setTimeout(() => {
                if (!isRunning) return;
                
                const minHeight = config.minHeight * window.innerHeight;
                const maxHeight = config.maxHeight * window.innerHeight;
                const yExplode = minHeight + Math.random() * (maxHeight - minHeight);
                
                createExplosion(x, yExplode, hue, type);
                
                if (Math.random() > 0.7) {
                    playSpecialBassExplosion(type, 1 + Math.random() * 0.5);
                }
            }, (type === 'largeNear' ? 800 : type === 'normalNear' ? 900 : 1100) + Math.random() * 600);
        }

        function createExplosion(x, y, baseHue, type) {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.8) return;

            const config = FIREWORK_CONFIG.fireworkTypes[type];
            const numParticles = Math.floor(
                (type === 'largeNear' ? 100 : type === 'normalNear' ? 80 : 60) * config.particleCountMultiplier
            );
            const explosionType = Math.random();
            
            // Tạo hiệu ứng sáng khi nổ
            createGlowEffect(x, y, type);
            
            if (explosionType < 0.5) {
                const segments = Math.floor(20 + Math.random() * 25);
                const particlesPerSegment = Math.floor(numParticles / segments);
                
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < particlesPerSegment; j++) {
                        const p = getParticle();
                        if (!p) continue;
                        
                        const angle = (Math.PI * 2 * i) / segments + (Math.random() - 0.5) * 0.5;
                        const speed = (5 + Math.random() * 8) * FIREWORK_CONFIG.explosionSpeedMultiplier * config.speedMultiplier;
                        
                        p.x = x;
                        p.y = y;
                        p.vx = Math.cos(angle) * speed;
                        p.vy = Math.sin(angle) * speed;
                        p.life = 0;
                        p.maxLife = (type === 'largeNear' ? 80 : type === 'normalNear' ? 70 : 60) + Math.random() * 50;
                        p.color = `hsl(${baseHue + Math.random()*80 - 40}, 100%, ${type === 'largeNear' ? 80 : type === 'normalNear' ? 75 : 70}%)`;
                        p.size = (0.8 + Math.random() * 1.2) * FIREWORK_CONFIG.particleSizeMultiplier * config.sizeMultiplier;
                        p.active = true;
                        p.type = type;
                        p.trail = true;
                        p.glowPower = config.glowIntensity;
                        p.initialGlow = config.glowIntensity * 0.8;
                    }
                }
            } else {
                for (let i = 0; i < numParticles * 1.2; i++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    p.x = x;
                    p.y = y;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (4 + Math.random() * 10) * FIREWORK_CONFIG.explosionSpeedMultiplier * config.speedMultiplier;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed * 0.8 - 2;
                    
                    p.life = 0;
                    p.maxLife = (type === 'largeNear' ? 70 : type === 'normalNear' ? 60 : 50) + Math.random() * 70;
                    
                    const hueVariation = Math.random() * 100 - 50;
                    p.color = `hsl(${baseHue + hueVariation}, ${type === 'largeNear' ? 100 : 95}%, ${type === 'largeNear' ? 85 : type === 'normalNear' ? 80 : 70}%)`;
                    
                    p.size = (0.6 + Math.random() * 1.6) * FIREWORK_CONFIG.particleSizeMultiplier * config.sizeMultiplier;
                    p.active = true;
                    p.type = type;
                    p.trail = true;
                    p.sparkle = Math.random() > 0.3;
                    p.trailLength = type === 'largeNear' ? 4 + Math.random() * 5 : 
                                  type === 'normalNear' ? 3 + Math.random() * 4 : 2 + Math.random() * 3;
                    p.glowPower = config.glowIntensity;
                    p.initialGlow = config.glowIntensity * 0.9;
                }
            }
        }

        function animate(time) {
            if (!isRunning) return;
            requestAnimationFrame(animate);
            
            const delta = lastTime === 0 ? 1 : Math.min((time - lastTime) / (1000 / FIREWORK_CONFIG.targetFPS), 2);
            lastTime = time;

            if (time > nextSoundTime) {
                const type = getRandomFireworkType();
                playDeepBass(type);
                nextSoundTime = time + SOUND_CONFIG.baseInterval + (Math.random() - 0.5) * SOUND_CONFIG.intervalVariation;
            }

            // Xóa màn hình với hiệu ứng mờ dần
            ctx.fillStyle = 'rgba(0,0,0,0.07)';
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            // Cập nhật và vẽ hiệu ứng sáng
            updateGlowEffects(delta);
            renderGlowEffects();

            // Vẽ tất cả các particle
            ctx.save();
            for (let p of particles) {
                if (!p.active) continue;

                p.x += p.vx * delta;
                p.y += p.vy * delta;

                if (!p.isRocket) {
                    p.vy += 0.10 * delta;
                }

                p.life += delta;
                if (p.life >= p.maxLife) {
                    p.active = false;
                    continue;
                }

                const progress = p.life / p.maxLife;
                let alpha = p.isRocket ? (1 - progress**1.8) : (1 - progress**1.5);

                if (p.sparkle && !p.isRocket) {
                    alpha *= 0.7 + 0.3 * Math.sin(progress * 30);
                }

                // Hiệu ứng sáng mờ dần
                const glowDecay = Math.max(0, 1 - (progress * 1.5));
                const glowIntensity = p.initialGlow * glowDecay;
                alpha *= glowIntensity;

                // Tăng độ sáng cho pháo lớn
                if (p.type === 'largeNear' && progress < 0.5) {
                    alpha *= 1.2;
                }

                const particleColor = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
                
                // Vẽ bóng sáng
                if (glowIntensity > 0.3) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    
                    const glowSize = p.size * glowIntensity * 2.5;
                    const glowGradient = ctx.createRadialGradient(
                        p.x, p.y, 0,
                        p.x, p.y, glowSize
                    );
                    
                    glowGradient.addColorStop(0, particleColor);
                    glowGradient.addColorStop(0.5, p.color.replace(')', `, ${alpha * 0.3})`).replace('hsl', 'hsla'));
                    glowGradient.addColorStop(1, p.color.replace(')', `, 0)`).replace('hsl', 'hsla'));
                    
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Vẽ particle chính
                ctx.fillStyle = particleColor;
                ctx.beginPath();
                
                // Hiệu ứng trail
                if (p.trailLength && progress < 0.4) {
                    ctx.shadowBlur = p.trailLength * glowIntensity;
                    ctx.shadowColor = p.color;
                } else if (p.trail && !p.isRocket && progress < 0.3) {
                    ctx.shadowBlur = (p.type === 'largeNear' ? 5 : p.type === 'normalNear' ? 4 : 3) * glowIntensity;
                    ctx.shadowColor = p.color;
                }
                
                const currentSize = p.size * (p.isRocket ? 1.1 : (1 - progress * 0.3));
                ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            ctx.restore();

            // Tạo pháo mới
            if (time > nextExplosionTime) {
                const intensity = Math.min(1 + (time - startTime) / 20000, FIREWORK_CONFIG.maxIntensity);
                const minInt = FIREWORK_CONFIG.explosionIntervalMin / intensity;
                const maxInt = FIREWORK_CONFIG.explosionIntervalMax / intensity;
                
                const activeCount = countActiveParticles();
                const activeFactor = Math.max(1, activeCount / (FIREWORK_CONFIG.maxActiveParticles * 0.6));
                const adjustedMinInt = minInt * activeFactor;
                const adjustedMaxInt = maxInt * activeFactor;
                
                createRocket();
                nextExplosionTime = time + Math.random() * (adjustedMaxInt - adjustedMinInt) + adjustedMinInt;
            }
        }

        // ====================== KHỞI ĐỘNG VỚI HIỆU ỨNG NÚT ======================
        const btn = document.getElementById('startBtn');
        
        async function start() {
            // Thêm hiệu ứng nhấn
            btn.classList.add('clicked');
            
            // Đợi hiệu ứng hoàn thành
            setTimeout(async () => {
                try {
                    await initBackgroundMusic();
                    
                    if (!initAudioSystem()) {
                        alert("Trình duyệt không hỗ trợ Web Audio API. Vui lòng dùng Chrome/Firefox/Safari mới nhất.");
                        btn.classList.remove('clicked');
                        btn.style.visibility = 'visible';
                        return;
                    }
                    
                    playBackgroundMusic();
                    
                    initCanvas();
                    createParticlePool();

                    if (masterGain) {
                        masterGain.gain.setValueAtTime(0.001, audioCtx.currentTime);
                        masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 2.5);
                    }

                    setTimeout(() => {
                        playSpecialBassExplosion('largeNear', 1.5);
                    }, 500);

                    isRunning = true;
                    startTime = performance.now();
                    lastTime = startTime;
                    nextExplosionTime = startTime + 500;
                    nextSoundTime = startTime + 1200;

                    requestAnimationFrame(animate);
                    
                } catch (error) {
                    console.error("Lỗi khởi tạo:", error);
                    alert("Có lỗi xảy ra khi khởi tạo. Vui lòng thử lại.");
                    btn.classList.remove('clicked');
                    btn.style.visibility = 'visible';
                }
            }, 800);
        }

        // ====================== EVENT LISTENERS ======================
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            start();
        }, { passive: false });
        
        btn.addEventListener('pointerdown', start);
        
        window.addEventListener('resize', () => {
            if (isRunning) initCanvas();
        });
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isRunning = false;
                pauseBackgroundMusic();
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                }
            } else if (startTime > 0) {
                isRunning = true;
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 0.5);
                }
                if (backgroundMusic && !isMusicPlaying) {
                    playBackgroundMusic();
                }
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
        
        window.addEventListener('beforeunload', () => {
            pauseBackgroundMusic();
        });
    </script>
</body>
</html>
