<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ph√°o Hoa ƒê·∫πp M·∫∑t - Ch·ªâ 1 Tia Bay L√™n</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: system-ui, sans-serif;
            color: #fff;
        }
        #canvas {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
        }
        #startBtn {
            position: relative;
            z-index: 10;
            padding: 18px 48px;
            font-size: 28px;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 32px rgba(102,126,234,0.4);
            transition: all 0.2s ease;
        }
        #startBtn:active {
            transform: scale(0.92);
            box-shadow: 0 4px 16px rgba(102,126,234,0.3);
        }
        #audioInfo {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #aaa;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        #musicInfo {
            position: absolute;
            bottom: 40px;
            right: 10px;
            color: #4CAF50;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        #orientationWarning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        #orientationWarning h2 {
            color: #ffcc00;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        #orientationWarning p {
            color: #fff;
            font-size: 18px;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.5;
        }
        .phone-icon {
            font-size: 60px;
            margin: 20px;
            animation: rotatePhone 2s infinite ease-in-out;
        }
        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(90deg); }
            75% { transform: rotate(90deg); }
        }
        #orientationCheck {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #aaa;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="orientationWarning">
        <h2>üì± VUI L√íNG XOAY NGANG ƒêI·ªÜN THO·∫†I üì±</h2>
        <p>ƒê·ªÉ c√≥ tr·∫£i nghi·ªám xem ph√°o hoa t·ªët nh·∫•t, vui l√≤ng xoay ngang ƒëi·ªán tho·∫°i c·ªßa b·∫°n.</p>
        <div class="phone-icon">üì±</div>
        <p style="color: #ffcc00; font-size: 16px;">M√†n h√¨nh s·∫Ω t·ª± ƒë·ªông hi·ªÉn th·ªã khi ƒëi·ªán tho·∫°i ƒë√£ xoay ngang</p>
    </div>
    
    <div id="orientationCheck">H∆∞·ªõng: <span id="orientationText">ƒêang ki·ªÉm tra...</span></div>
    
    <button id="startBtn">B·∫ÆT ƒê·∫¶U PH√ÅO HOA</button>
    <canvas id="canvas"></canvas>
    <div id="audioInfo">√Çm thanh: ƒêang ph√°t...</div>
    <div id="musicInfo">üéµ Nh·∫°c: ƒêang t·∫£i...</div>

    <script>
        // C·∫§U H√åNH √ÇM THANH (CH·ªà TR·∫¶M)
        const SOUND_CONFIG = {
            // √Çm l∆∞·ª£ng t·ªïng
            masterVolume: 1.3,
            
            // Kho·∫£ng th·ªùi gian ph√°t √¢m thanh (ms)
            baseInterval: 1600,
            intervalVariation: 1000,
            
            // Th·ªùi l∆∞·ª£ng fade in/out
            fadeInTime: 0.2,
            fadeOutTime: 1.2,
            
            // T·∫ßn s·ªë ph·ªëi h·ª£p (CH·ªà TR·∫¶M)
            frequencyBlend: {
                min: 30,
                max: 80,
                glideTime: 0.6
            },
            
            // Layer √¢m thanh (CH·ªà TR·∫¶M)
            layers: {
                sub: { weight: 1.0, freqRange: [30, 70] },
                deep: { weight: 0.7, freqRange: [20, 45] },
                rumble: { weight: 0.4, freqRange: [100, 300] }
            }
        };

        // C·∫§U H√åNH PH√ÅO HOA - ƒêI·ªÄU CH·ªàNH CHO ƒêI·ªÜN THO·∫†I
        const FIREWORK_CONFIG = {
            maxParticlesPerExplosion: 80,           // GI·∫¢M s·ªë h·∫°t cho ƒëi·ªán tho·∫°i
            maxIntensity: 2.5,                      // GI·∫¢M c∆∞·ªùng ƒë·ªô
            explosionIntervalMin: 1500,             // TƒÇNG kho·∫£ng c√°ch
            explosionIntervalMax: 2500,
            targetFPS: 60,
            maxActiveParticles: 1200,               // GI·∫¢M particle t·ªëi ƒëa
            particleSizeMultiplier: 0.7,            // GI·∫¢M k√≠ch th∆∞·ªõc h·∫°t
            rocketSpeedMultiplier: 0.8,             // GI·∫¢M t·ªëc ƒë·ªô rocket
            explosionSpeedMultiplier: 0.7           // GI·∫¢M t·ªëc ƒë·ªô n·ªï
        };

        // ƒê∆Ø·ªúNG D·∫™N FILE NH·∫†C
        const MUSIC_FILE = 'phaobong.mp3';

        let canvas, ctx, audioCtx, masterGain, backgroundMusic;
        let particles = [];
        let particlePoolSize = FIREWORK_CONFIG.maxParticlesPerExplosion * 25; // GI·∫¢M pool size
        let lastTime = 0, startTime = 0;
        let isRunning = false;
        let nextExplosionTime = 0;
        let nextSoundTime = 0;
        let soundSequence = 0;
        let activeSounds = new Set();
        let isMusicLoaded = false;
        let isMusicPlaying = false;
        let isPortrait = false;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // ====================== KI·ªÇM TRA H∆Ø·ªöNG M√ÄN H√åNH ======================
        function checkOrientation() {
            const orientationWarning = document.getElementById('orientationWarning');
            const orientationCheck = document.getElementById('orientationCheck');
            const orientationText = document.getElementById('orientationText');
            
            // Ki·ªÉm tra xem c√≥ ph·∫£i mobile kh√¥ng
            if (!isMobile) {
                orientationWarning.style.display = 'none';
                orientationCheck.style.display = 'none';
                isPortrait = false;
                return;
            }
            
            // Ki·ªÉm tra h∆∞·ªõng m√†n h√¨nh
            const isPortraitMode = window.innerHeight > window.innerWidth;
            isPortrait = isPortraitMode;
            
            if (isPortraitMode) {
                // Ch·∫ø ƒë·ªô d·ªçc - hi·ªÉn th·ªã c·∫£nh b√°o
                orientationWarning.style.display = 'flex';
                orientationCheck.style.display = 'block';
                orientationText.textContent = 'D·ªåC ‚ö†Ô∏è';
                orientationText.style.color = '#ff6b6b';
                
                // ·∫®n n√∫t b·∫Øt ƒë·∫ßu n·∫øu ƒëang hi·ªÉn th·ªã
                const startBtn = document.getElementById('startBtn');
                if (startBtn.style.display !== 'none') {
                    startBtn.style.display = 'none';
                }
            } else {
                // Ch·∫ø ƒë·ªô ngang - ·∫©n c·∫£nh b√°o
                orientationWarning.style.display = 'none';
                orientationCheck.style.display = 'block';
                orientationText.textContent = 'NGANG ‚úÖ';
                orientationText.style.color = '#4CAF50';
                
                // Hi·ªÉn th·ªã n√∫t b·∫Øt ƒë·∫ßu n·∫øu ch∆∞a b·∫Øt ƒë·∫ßu
                const startBtn = document.getElementById('startBtn');
                if (!isRunning && startBtn.style.display === 'none') {
                    startBtn.style.display = 'block';
                }
            }
        }

        // ====================== H·ªÜ TH·ªêNG NH·∫†C N·ªÄN ======================
        function initBackgroundMusic() {
            return new Promise((resolve, reject) => {
                try {
                    backgroundMusic = new Audio();
                    backgroundMusic.src = MUSIC_FILE;
                    backgroundMusic.loop = true;
                    backgroundMusic.volume = 0.7;
                    backgroundMusic.preload = 'auto';
                    
                    backgroundMusic.addEventListener('loadeddata', () => {
                        console.log("‚úÖ Nh·∫°c n·ªÅn ƒë√£ t·∫£i xong");
                        isMusicLoaded = true;
                        updateMusicInfo('üéµ Nh·∫°c: S·∫µn s√†ng');
                        resolve(true);
                    });
                    
                    backgroundMusic.addEventListener('error', (e) => {
                        console.error("‚ùå L·ªói t·∫£i nh·∫°c:", e);
                        updateMusicInfo('‚ùå L·ªói t·∫£i nh·∫°c');
                        reject(new Error("Kh√¥ng th·ªÉ t·∫£i nh·∫°c n·ªÅn"));
                    });
                    
                    backgroundMusic.addEventListener('play', () => {
                        isMusicPlaying = true;
                        updateMusicInfo('üéµ Nh·∫°c: ƒêang ph√°t');
                    });
                    
                    backgroundMusic.addEventListener('pause', () => {
                        isMusicPlaying = false;
                        updateMusicInfo('üéµ Nh·∫°c: ƒê√£ d·ª´ng');
                    });
                    
                    backgroundMusic.load();
                    
                } catch (e) {
                    console.error("‚ùå L·ªói kh·ªüi t·∫°o nh·∫°c:", e);
                    reject(e);
                }
            });
        }

        function updateMusicInfo(text) {
            const musicInfo = document.getElementById('musicInfo');
            musicInfo.textContent = text;
            musicInfo.style.display = 'block';
            
            if (!text.includes('ƒêang ph√°t') && !text.includes('S·∫µn s√†ng')) {
                setTimeout(() => {
                    if (!isMusicPlaying) {
                        musicInfo.style.display = 'none';
                    }
                }, 3000);
            }
        }

        function playBackgroundMusic() {
            if (!backgroundMusic || !isMusicLoaded) {
                updateMusicInfo('‚ùå Ch∆∞a t·∫£i ƒë∆∞·ª£c nh·∫°c');
                return false;
            }
            
            try {
                backgroundMusic.volume = 0;
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        fadeMusicVolume(0, 0.7, 1.5);
                    }).catch(error => {
                        console.error("‚ùå L·ªói ph√°t nh·∫°c:", error);
                        updateMusicInfo('‚ùå L·ªói ph√°t nh·∫°c');
                    });
                }
                
                return true;
            } catch (e) {
                console.error("‚ùå L·ªói khi ph√°t nh·∫°c:", e);
                updateMusicInfo('‚ùå L·ªói ph√°t nh·∫°c');
                return false;
            }
        }

        function fadeMusicVolume(from, to, duration) {
            if (!backgroundMusic) return;
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            function updateVolume() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / (duration * 1000), 1);
                const currentVolume = from + (to - from) * progress;
                
                backgroundMusic.volume = Math.max(0, Math.min(1, currentVolume));
                
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }

        function pauseBackgroundMusic() {
            if (backgroundMusic && isMusicPlaying) {
                backgroundMusic.pause();
                isMusicPlaying = false;
            }
        }

        // ====================== H·ªÜ TH·ªêNG √ÇM THANH (CH·ªà TR·∫¶M) ======================
        function initAudioSystem() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioCtx.createGain();
                masterGain.gain.value = SOUND_CONFIG.masterVolume;
                
                const compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -20;
                compressor.knee.value = 30;
                compressor.ratio.value = 6;
                compressor.attack.value = 0.03;
                compressor.release.value = 0.3;
                
                const lowShelf = audioCtx.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 150;
                lowShelf.gain.value = 8;
                
                masterGain.connect(lowShelf).connect(compressor).connect(audioCtx.destination);
                
                return true;
            } catch (e) {
                console.log("Audio kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£");
                return false;
            }
        }

        function createBassSound(frequency, type = 'sine', duration = 1.0, volume = 1.0) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.value = frequency;
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + SOUND_CONFIG.fadeInTime);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            const soundId = Symbol();
            activeSounds.add(soundId);
            
            setTimeout(() => {
                activeSounds.delete(soundId);
            }, duration * 1000);
            
            return soundId;
        }

        function createBassGlide(startFreq, endFreq, type = 'sine', duration = 1.2, volume = 0.9) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(endFreq, now + SOUND_CONFIG.frequencyBlend.glideTime);
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            return Symbol();
        }

        function createRumbleSound(duration = 0.8, baseFreq = 120, volume = 0.5) {
            const now = audioCtx.currentTime;
            
            for (let i = 0; i < 3; i++) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = baseFreq + (i * 15);
                
                gain.gain.setValueAtTime(0.001, now + (i * 0.05));
                gain.gain.exponentialRampToValueAtTime(volume * (0.7 - i * 0.2), now + (i * 0.05) + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(gain).connect(masterGain);
                osc.start(now + (i * 0.05));
                osc.stop(now + duration);
            }
            
            return Symbol();
        }

        // ====================== C√ÅC B·ªò √ÇM THANH BASS ======================
        
        function playDeepBass() {
            const baseFreq = 35 + Math.random() * 20;
            
            createBassSound(
                baseFreq,
                'sine',
                1.4,
                SOUND_CONFIG.layers.sub.weight * 1.0
            );
            
            setTimeout(() => {
                createBassSound(
                    baseFreq * 0.5,
                    'sine',
                    1.6,
                    SOUND_CONFIG.layers.deep.weight * 0.6
                );
            }, 200);
            
            setTimeout(() => {
                createRumbleSound(
                    0.6,
                    80 + Math.random() * 40,
                    SOUND_CONFIG.layers.rumble.weight * 0.3
                );
            }, 150);
        }

        function playBassGlide() {
            const startFreq = 50 + Math.random() * 20;
            const endFreq = startFreq * 0.6;
            
            createBassGlide(
                startFreq,
                endFreq,
                'sine',
                1.3,
                SOUND_CONFIG.layers.sub.weight * 0.9
            );
            
            setTimeout(() => {
                createBassSound(
                    startFreq * 1.5,
                    'sine',
                    1.0,
                    SOUND_CONFIG.layers.sub.weight * 0.4
                );
            }, 300);
        }

        function playDualBass() {
            const freq1 = 40 + Math.random() * 15;
            const freq2 = 55 + Math.random() * 20;
            
            createBassSound(
                freq1,
                'sine',
                1.2,
                SOUND_CONFIG.layers.sub.weight * 0.8
            );
            
            setTimeout(() => {
                createBassSound(
                    freq2,
                    'sine',
                    1.1,
                    SOUND_CONFIG.layers.sub.weight * 0.7
                );
            }, 100);
            
            setTimeout(() => {
                createBassSound(
                    Math.min(freq1, freq2) * 0.4,
                    'sine',
                    1.5,
                    SOUND_CONFIG.layers.deep.weight * 0.5
                );
            }, 250);
        }

        function playPowerBass() {
            const now = Date.now();
            const timeFactor = Math.sin(now * 0.001) * 0.5 + 0.5;
            
            const mainFreq = 30 + timeFactor * 20;
            createBassSound(
                mainFreq,
                'sine',
                1.6,
                SOUND_CONFIG.layers.sub.weight * (0.9 + timeFactor * 0.3)
            );
            
            setTimeout(() => {
                createBassSound(
                    mainFreq * 0.75,
                    'sine',
                    1.4,
                    SOUND_CONFIG.layers.deep.weight * 0.6
                );
                
                createBassSound(
                    mainFreq * 0.6,
                    'sine',
                    1.5,
                    SOUND_CONFIG.layers.deep.weight * 0.4
                );
            }, 150);
            
            setTimeout(() => {
                createRumbleSound(
                    0.9,
                    60 + Math.random() * 30,
                    SOUND_CONFIG.layers.rumble.weight * 0.5
                );
            }, 200);
        }

        function playSpecialBassExplosion(intensity = 1.0) {
            const baseFreq = 40 + Math.random() * 20;
            const duration = 1.4 + intensity * 0.5;
            
            createBassGlide(
                baseFreq * 1.4,
                baseFreq * 0.5,
                'sine',
                duration,
                SOUND_CONFIG.layers.sub.weight * intensity * 1.3
            );
            
            setTimeout(() => {
                createBassSound(
                    baseFreq * 0.8,
                    'sine',
                    duration * 0.9,
                    SOUND_CONFIG.layers.deep.weight * intensity * 0.8
                );
                
                createBassSound(
                    baseFreq * 0.6,
                    'sine',
                    duration * 1.1,
                    SOUND_CONFIG.layers.deep.weight * intensity * 0.6
                );
            }, 100);
            
            setTimeout(() => {
                createRumbleSound(
                    duration * 0.8,
                    50 + Math.random() * 20,
                    SOUND_CONFIG.layers.rumble.weight * intensity * 0.7
                );
            }, 180);
        }

        function playBassSound() {
            if (!audioCtx || activeSounds.size > 4) return;
            
            soundSequence = (soundSequence + 1) % 4;
            
            switch(soundSequence) {
                case 0:
                    playDeepBass();
                    break;
                case 1:
                    playBassGlide();
                    break;
                case 2:
                    playDualBass();
                    break;
                case 3:
                    playPowerBass();
                    break;
            }
            
            const variation = (Math.random() - 0.5) * SOUND_CONFIG.intervalVariation;
            nextSoundTime = performance.now() + SOUND_CONFIG.baseInterval + variation;
            
            updateAudioInfo();
        }

        function updateAudioInfo() {
            const info = document.getElementById('audioInfo');
            const activeCount = activeSounds.size;
            const layers = ['üéµ Bass S√¢u', 'üé∂ Bass Glide', 'üîä Dual Bass', 'üí• Power Bass'][soundSequence % 4];
            
            info.textContent = `√Çm thanh: ${layers} | ƒêang ph√°t: ${activeCount}`;
            info.style.color = activeCount > 3 ? '#ff6b6b' : 
                             activeCount > 1 ? '#ffd166' : '#06d6a0';
        }

        // ====================== H·ªÜ TH·ªêNG PH√ÅO HOA (ƒêI·ªÄU CH·ªàNH CHO MOBILE) ======================
        function createParticlePool() {
            particles = [];
            for (let i = 0; i < particlePoolSize; i++) {
                particles.push({
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 0,
                    color: '#fff',
                    size: 1.5 * FIREWORK_CONFIG.particleSizeMultiplier, // GI·∫¢M size
                    active: false
                });
            }
        }

        function getParticle() {
            for (let p of particles) {
                if (!p.active) return p;
            }
            
            let oldestParticle = null;
            let oldestLife = 0;
            for (let p of particles) {
                if (p.active) {
                    const lifeRatio = p.life / p.maxLife;
                    if (lifeRatio > oldestLife) {
                        oldestLife = lifeRatio;
                        oldestParticle = p;
                    }
                }
            }
            
            if (oldestParticle && oldestLife > 0.8) {
                oldestParticle.active = false;
                return oldestParticle;
            }
            
            return null;
        }

        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            const dpr = Math.min(window.devicePixelRatio || 1, 1.2); // GI·∫¢M DPR cho mobile
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = `${window.innerWidth}px`;
            canvas.style.height = `${window.innerHeight}px`;
            ctx.scale(dpr, dpr);
            canvas.style.display = 'block';
        }

        function countActiveParticles() {
            let count = 0;
            for (let p of particles) {
                if (p.active) count++;
            }
            return count;
        }

        function createRocket() {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles) return;

            const x = Math.random() * window.innerWidth;
            const yStart = window.innerHeight;
            const hue = Math.random() * 360;

            const p = getParticle();
            if (p) {
                p.x = x;
                p.y = yStart;
                p.vx = (Math.random() - 0.5) * 1.2;
                p.vy = - (12 + Math.random() * 6) * FIREWORK_CONFIG.rocketSpeedMultiplier; // GI·∫¢M t·ªëc ƒë·ªô
                p.life = 0;
                p.maxLife = 50 + Math.random() * 20;
                p.color = `hsl(${hue}, 100%, 70%)`;
                p.size = (2.0 + Math.random() * 1.0) * FIREWORK_CONFIG.particleSizeMultiplier; // GI·∫¢M size
                p.active = true;
                p.isRocket = true;
                p.trailHue = hue;
            }

            setTimeout(() => {
                if (!isRunning) return;
                const yExplode = window.innerHeight * (0.15 + Math.random() * 0.45);
                createExplosion(x, yExplode, hue);
                
                if (Math.random() > 0.7) {
                    playSpecialBassExplosion(1 + Math.random() * 0.5);
                }
            }, 1000 + Math.random() * 600);
        }

        function createExplosion(x, y, baseHue) {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.8) return;

            const numParticles = Math.floor(80 + Math.random() * 70);
            const explosionType = Math.random();
            
            if (explosionType < 0.5) {
                const segments = Math.floor(20 + Math.random() * 25);
                const particlesPerSegment = Math.floor(numParticles / segments);
                
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < particlesPerSegment; j++) {
                        const p = getParticle();
                        if (!p) continue;
                        
                        const angle = (Math.PI * 2 * i) / segments + (Math.random() - 0.5) * 0.5;
                        const speed = (5 + Math.random() * 8) * FIREWORK_CONFIG.explosionSpeedMultiplier; // GI·∫¢M t·ªëc ƒë·ªô
                        
                        p.x = x;
                        p.y = y;
                        p.vx = Math.cos(angle) * speed;
                        p.vy = Math.sin(angle) * speed;
                        p.life = 0;
                        p.maxLife = 60 + Math.random() * 50;
                        p.color = `hsl(${baseHue + Math.random()*80 - 40}, 100%, ${60 + Math.random()*30}%)`;
                        p.size = (1.0 + Math.random() * 1.5) * FIREWORK_CONFIG.particleSizeMultiplier; // GI·∫¢M size
                        p.active = true;
                        p.trail = true;
                    }
                }
            } else {
                for (let i = 0; i < numParticles * 1.2; i++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    p.x = x;
                    p.y = y;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (4 + Math.random() * 10) * FIREWORK_CONFIG.explosionSpeedMultiplier; // GI·∫¢M t·ªëc ƒë·ªô
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed * 0.8 - 2;
                    
                    p.life = 0;
                    p.maxLife = 50 + Math.random() * 70;
                    
                    const hueVariation = Math.random() * 100 - 50;
                    p.color = `hsl(${baseHue + hueVariation}, ${80 + Math.random()*20}%, ${50 + Math.random()*40}%)`;
                    
                    p.size = (0.8 + Math.random() * 2.0) * FIREWORK_CONFIG.particleSizeMultiplier; // GI·∫¢M size
                    p.active = true;
                    p.trail = true;
                    p.sparkle = Math.random() > 0.3;
                    p.trailLength = 2 + Math.random() * 3; // GI·∫¢M trail length
                }
            }
        }

        function animate(time) {
            if (!isRunning) return;
            requestAnimationFrame(animate);
            
            const delta = lastTime === 0 ? 1 : Math.min((time - lastTime) / (1000 / FIREWORK_CONFIG.targetFPS), 2);
            lastTime = time;

            if (time > nextSoundTime) {
                playBassSound();
            }

            ctx.fillStyle = 'rgba(0,0,0,0.08)';
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            ctx.save();
            for (let p of particles) {
                if (!p.active) continue;

                p.x += p.vx * delta;
                p.y += p.vy * delta;

                if (!p.isRocket) {
                    p.vy += 0.10 * delta;
                }

                p.life += delta;
                if (p.life >= p.maxLife) {
                    p.active = false;
                    continue;
                }

                const progress = p.life / p.maxLife;
                let alpha = p.isRocket ? (1 - progress**1.8) : (1 - progress**1.5);

                if (p.sparkle && !p.isRocket) {
                    alpha *= 0.6 + 0.4 * Math.sin(progress * 25);
                }

                ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
                ctx.beginPath();
                
                if (p.trailLength && progress < 0.4) {
                    ctx.shadowBlur = p.trailLength;
                    ctx.shadowColor = p.color;
                } else if (p.trail && !p.isRocket && progress < 0.3) {
                    ctx.shadowBlur = 3 + Math.random() * 3; // GI·∫¢M shadow blur
                    ctx.shadowColor = p.color;
                }
                
                const currentSize = p.size * (p.isRocket ? 1.1 : (1 - progress * 0.3)); // GI·∫¢M rocket scale
                ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            ctx.restore();

            if (time > nextExplosionTime) {
                const intensity = Math.min(1 + (time - startTime) / 20000, FIREWORK_CONFIG.maxIntensity);
                const minInt = FIREWORK_CONFIG.explosionIntervalMin / intensity;
                const maxInt = FIREWORK_CONFIG.explosionIntervalMax / intensity;
                
                const activeCount = countActiveParticles();
                const activeFactor = Math.max(1, activeCount / (FIREWORK_CONFIG.maxActiveParticles * 0.6));
                const adjustedMinInt = minInt * activeFactor;
                const adjustedMaxInt = maxInt * activeFactor;
                
                createRocket();
                nextExplosionTime = time + Math.random() * (adjustedMaxInt - adjustedMinInt) + adjustedMinInt;
            }
        }

        // ====================== KH·ªûI ƒê·ªòNG ======================
        const btn = document.getElementById('startBtn');
        
        async function start() {
            // Ki·ªÉm tra h∆∞·ªõng m√†n h√¨nh tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
            if (isMobile && isPortrait) {
                alert("Vui l√≤ng xoay ngang ƒëi·ªán tho·∫°i ƒë·ªÉ b·∫Øt ƒë·∫ßu xem ph√°o hoa!");
                return;
            }
            
            btn.disabled = true;
            btn.textContent = "ƒêANG T·∫¢I...";
            
            try {
                updateMusicInfo('üéµ ƒêang t·∫£i nh·∫°c...');
                
                await initBackgroundMusic();
                
                btn.textContent = "B·∫ÆT ƒê·∫¶U PH√ÅO HOA";
                btn.disabled = false;
                
                btn.style.opacity = '0';
                btn.style.pointerEvents = 'none';
                setTimeout(() => btn.style.display = 'none', 600);

                if (!initAudioSystem()) {
                    alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Audio API. Vui l√≤ng d√πng Chrome/Firefox/Safari m·ªõi nh·∫•t.");
                    return;
                }
                
                const musicStarted = playBackgroundMusic();
                if (!musicStarted) {
                    console.warn("Kh√¥ng th·ªÉ ph√°t nh·∫°c n·ªÅn, ti·∫øp t·ª•c v·ªõi √¢m thanh ph√°o hoa...");
                }
                
                initCanvas();
                createParticlePool();

                if (masterGain) {
                    masterGain.gain.setValueAtTime(0.001, audioCtx.currentTime);
                    masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 2.5);
                }

                setTimeout(() => {
                    playPowerBass();
                }, 500);

                isRunning = true;
                startTime = performance.now();
                lastTime = startTime;
                nextExplosionTime = startTime + 500;
                nextSoundTime = startTime + 1200;

                document.getElementById('audioInfo').style.display = 'block';

                requestAnimationFrame(animate);
                
            } catch (error) {
                console.error("L·ªói kh·ªüi t·∫°o:", error);
                alert("C√≥ l·ªói x·∫£y ra khi kh·ªüi t·∫°o. Vui l√≤ng th·ª≠ l·∫°i.");
                btn.disabled = false;
                btn.textContent = "B·∫ÆT ƒê·∫¶U PH√ÅO HOA";
            }
        }

        // ====================== EVENT LISTENERS ======================
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            start();
        }, { passive: false });
        
        btn.addEventListener('pointerdown', start);
        
        // Ki·ªÉm tra h∆∞·ªõng m√†n h√¨nh khi resize v√† orientation change
        window.addEventListener('resize', () => {
            checkOrientation();
            if (isRunning) initCanvas();
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(checkOrientation, 100); // Delay ƒë·ªÉ ch·ªù rotation ho√†n t·∫•t
        });
        
        // Ki·ªÉm tra ngay khi trang t·∫£i
        document.addEventListener('DOMContentLoaded', checkOrientation);
        
        // Ki·ªÉm tra khi b·∫Øt ƒë·∫ßu
        checkOrientation();
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isRunning = false;
                pauseBackgroundMusic();
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                }
            } else if (startTime > 0) {
                isRunning = true;
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 0.5);
                }
                if (backgroundMusic && !isMusicPlaying) {
                    playBackgroundMusic();
                }
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
        
        window.addEventListener('beforeunload', () => {
            pauseBackgroundMusic();
        });
    </script>
</body>
</html>
