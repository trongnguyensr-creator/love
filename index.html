<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pháo Hoa</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: system-ui, sans-serif;
            color: #fff;
        }
        #canvas {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
        }
        #startBtn {
    position: relative;
    z-index: 10;
    padding: 20px 54px;
    font-size: 30px;
    font-weight: 700;
    color: #111;
    background: linear-gradient(
        135deg,
        #ffffff,
        #f3f3f3
    );
    border: 1px solid rgba(0, 0, 0, 0.08);
    border-radius: 28px;
    cursor: pointer;
    box-shadow:
        0 10px 25px rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    transition:
        transform 0.35s cubic-bezier(.22,1,.36,1),
        box-shadow 0.35s ease,
        background 0.35s ease;
    letter-spacing: 0.5px;
    animation: floatSoft 4s ease-in-out infinite;
    overflow: hidden;
}

#startBtn::after {
    content: "";
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(
        120deg,
        transparent,
        rgba(255,255,255,0.7),
        transparent
    );
    transition: left 0.6s ease;
}

#startBtn:hover::after {
    left: 120%;
}

#startBtn:hover {
    transform: translateY(-6px);
    box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 1);
}

#startBtn:active {
    transform: scale(0.92);
    box-shadow:
        0 6px 15px rgba(0, 0, 0, 0.15);
    transition: transform 0.15s ease;
}

#startBtn.clicked {
    animation: fadeOutSmooth 0.9s cubic-bezier(.4,0,.2,1) forwards;
}

.btn-text {
    position: relative;
    z-index: 1;
    color: #111;
}

@keyframes floatSoft {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-8px);
    }
}

@keyframes fadeOutSmooth {
    0% {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
    40% {
        opacity: 0.8;
        transform: scale(1.05) translateY(-16px);
    }
    100% {
        opacity: 0;
        transform: scale(0.7) translateY(60px);
        visibility: hidden;
    }
}

        /* Container cho ảnh kết thúc */
        #imageContainer {
            position: absolute;
            inset: 0;
            z-index: 2;
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        .ending-image {
            position: absolute;
            max-width: 80%;
            max-height: 80%;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 2.5s cubic-bezier(0.16, 1, 0.3, 1),
                        transform 2.5s cubic-bezier(0.16, 1, 0.3, 1);
            filter: blur(10px) brightness(1.1);
            border-radius: 20px;
            box-shadow: 0 0 60px rgba(255, 255, 255, 0.15);
        }

        .ending-image.visible {
            opacity: 0.9;
            transform: scale(1);
            filter: blur(5px) brightness(1.2);
        }

        .ending-image.final {
            opacity: 0.95;
            filter: blur(3px) brightness(1.3);
        }

        .image-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg, 
                rgba(255, 200, 100, 0.15),
                rgba(255, 100, 200, 0.1),
                rgba(100, 200, 255, 0.1));
            mix-blend-mode: overlay;
            pointer-events: none;
        }

    </style>
</head>
<body>
    <button id="startBtn">
        <span class="btn-text">BẮT ĐẦU</span>
    </button>
    <canvas id="canvas"></canvas>
    
    <!-- Container cho ảnh kết thúc -->
    <div id="imageContainer">
        <div class="image-overlay"></div>
    </div>

    <script>
        // CẤU HÌNH ÂM THANH (CHỈ TRẦM)
        const SOUND_CONFIG = {
            masterVolume: 1.3,
            baseInterval: 1600,
            intervalVariation: 1000,
            fadeInTime: 0.2,
            fadeOutTime: 1.2,
            frequencyBlend: {
                min: 30,
                max: 80,
                glideTime: 0.6
            },
            layers: {
                sub: { weight: 1.0, freqRange: [30, 70] },
                deep: { weight: 0.7, freqRange: [20, 45] },
                rumble: { weight: 0.4, freqRange: [100, 300] }
            }
        };

        // CẤU HÌNH PHÁO HOA - VỚI HỆ THỐNG KẾT THÚC CAO TRÀO
        const FIREWORK_CONFIG = {
            maxParticlesPerExplosion: 120,
            maxIntensity: 3.0,
            
            // Hệ thống điều chỉnh tốc độ - CẢI TIẾN
            adaptiveExplosionRate: {
                // Tốc độ bình thường
                normalRate: {
                    minInterval: 1800,
                    maxInterval: 2800
                },
                
                // Tốc độ cao trào (dồn dập)
                climaxRate: {
                    minInterval: 200,
                    maxInterval: 500,
                    duration: 10000
                },
                
                // Các giai đoạn
                phases: {
                    buildup: 10000,
                    climax: 10000,
                    cooldown: 10000,
                    finale: 5000  // Thêm giai đoạn kết thúc
                }
            },
            
            targetFPS: 60,
            maxActiveParticles: 1800,
            particleSizeMultiplier: 0.6,
            rocketSpeedMultiplier: 0.85,
            explosionSpeedMultiplier: 0.75,
            
            // CẤU HÌNH KHOẢNG CÁCH: 30% gần, 70% xa
            distanceDistribution: {
                near: 0.3,
                far: 0.7
            },
            
            distanceSettings: {
                near: {
                    minHeight: 0.15,
                    maxHeight: 0.45,
                    sizeMultiplier: 1.3,
                    speedMultiplier: 1.15,
                    brightnessBoost: 1.2,
                    glowIntensity: 1.4
                },
                far: {
                    minHeight: 0.55,
                    maxHeight: 0.85,
                    sizeMultiplier: 0.75,
                    speedMultiplier: 0.88,
                    brightnessBoost: 0.9,
                    glowIntensity: 0.8
                }
            },
            
            // CÁC LOẠI PHÁO HOA
            explosionTypes: {
                normal: {
                    chrysanthemum: 0.25,
                    peony: 0.25,
                    palm: 0.15,
                    willow: 0.15,
                    ring: 0.10,
                    crossette: 0.10
                },
                climax: {
                    chrysanthemum: 0.15,
                    peony: 0.20,
                    palm: 0.10,
                    willow: 0.10,
                    ring: 0.15,
                    crossette: 0.15,
                    special: 0.15
                }
            }
        };

        // ĐƯỜNG DẪN FILE NHẠC VÀ ẢNH
        const MUSIC_FILE = 'phaobong.mp3';
        const ENDING_IMAGES = ['1.png', '2.png', '3.png'];

        let canvas, ctx, audioCtx, masterGain, backgroundMusic;
        let particles = [];
        let particlePoolSize = FIREWORK_CONFIG.maxParticlesPerExplosion * 35;
        let lastTime = 0, startTime = 0;
        let isRunning = false;
        let nextExplosionTime = 0;
        let nextSoundTime = 0;
        let soundSequence = 0;
        let activeSounds = new Set();
        let isMusicLoaded = false;
        let isMusicPlaying = false;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        // Hệ thống cao trào và kết thúc
        let climaxSystem = {
            phase: 'buildup',
            phaseStartTime: 0,
            climaxIntensity: 1.0,
            isClimaxActive: false,
            climaxMultiplier: 1.0,
            specialFireworkCounter: 0,
            
            // Kết thúc cao trào
            isFinaleActive: false,
            finaleFireworks: [],
            finaleStep: 0,
            imageDisplayIndex: 0,
            imagesLoaded: false,
            endingImages: []
        };

        // ====================== HỆ THỐNG TẢI ẢNH KẾT THÚC ======================
        function loadEndingImages() {
            return new Promise((resolve, reject) => {
                const promises = ENDING_IMAGES.map((src, index) => {
                    return new Promise((resolveImg, rejectImg) => {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.src = src;
                        
                        img.onload = () => {
                            // Tạo canvas để làm mờ ảnh
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Đặt kích thước canvas (giảm độ phân giải để tối ưu)
                            const maxWidth = Math.min(window.innerWidth * 0.8, 800);
                            const maxHeight = Math.min(window.innerHeight * 0.8, 600);
                            
                            // Tính toán kích thước giữ nguyên tỷ lệ
                            let width = img.width;
                            let height = img.height;
                            
                            if (width > maxWidth) {
                                height = (maxWidth / width) * height;
                                width = maxWidth;
                            }
                            
                            if (height > maxHeight) {
                                width = (maxHeight / height) * width;
                                height = maxHeight;
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            
                            // Vẽ ảnh gốc
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Áp dụng hiệu ứng làm mờ và chỉnh màu
                            applyImageEffects(ctx, width, height);
                            
                            // Lưu URL ảnh đã xử lý
                            climaxSystem.endingImages[index] = {
                                original: img,
                                processed: canvas.toDataURL('image/png'),
                                width: width,
                                height: height
                            };
                            
                            resolveImg();
                        };
                        
                        img.onerror = () => {
                            console.warn(`Không thể tải ảnh: ${src}`);
                            // Tạo ảnh placeholder nếu lỗi
                            createPlaceholderImage(index).then(resolveImg);
                        };
                    });
                });
                
                Promise.all(promises)
                    .then(() => {
                        climaxSystem.imagesLoaded = true;
                        resolve();
                    })
                    .catch(reject);
            });
        }

        function createPlaceholderImage(index) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const width = 400;
                const height = 300;
                
                canvas.width = width;
                canvas.height = height;
                
                // Tạo gradient nền
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, `hsl(${index * 120}, 70%, 20%)`);
                gradient.addColorStop(1, `hsl(${index * 120 + 60}, 70%, 30%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                
                // Thêm hiệu ứng ánh sáng
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 3;
                
                const radialGradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, radius
                );
                
                radialGradient.addColorStop(0, `hsla(${index * 120}, 100%, 80%, 0.4)`);
                radialGradient.addColorStop(1, `hsla(${index * 120}, 100%, 80%, 0)`);
                
                ctx.fillStyle = radialGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Thêm text
                ctx.fillStyle = `hsla(${index * 120}, 100%, 90%, 0.7)`;
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`HÌNH ${index + 1}`, centerX, centerY);
                
                // Áp dụng hiệu ứng
                applyImageEffects(ctx, width, height);
                
                climaxSystem.endingImages[index] = {
                    original: null,
                    processed: canvas.toDataURL('image/png'),
                    width: width,
                    height: height
                };
                
                resolve();
            });
        }

        function applyImageEffects(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Áp dụng Gaussian blur (đơn giản)
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.putImageData(imageData, 0, 0);
            
            // Áp dụng blur nhiều lần
            for (let i = 0; i < 3; i++) {
                tempCtx.filter = 'blur(4px)';
                tempCtx.drawImage(tempCanvas, 0, 0);
            }
            
            // Lấy lại imageData đã blur
            const blurredData = tempCtx.getImageData(0, 0, width, height);
            const blurred = blurredData.data;
            
            // Trộn ảnh gốc với ảnh đã blur (30% blur, 70% gốc)
            for (let i = 0; i < data.length; i += 4) {
                data[i] = data[i] * 0.7 + blurred[i] * 0.3;     // R
                data[i + 1] = data[i + 1] * 0.7 + blurred[i + 1] * 0.3; // G
                data[i + 2] = data[i + 2] * 0.7 + blurred[i + 2] * 0.3; // B
                
                // Tăng độ sáng
                data[i] = Math.min(255, data[i] * 1.1);
                data[i + 1] = Math.min(255, data[i + 1] * 1.1);
                data[i + 2] = Math.min(255, data[i + 2] * 1.1);
                
                // Thêm chút ánh vàng
                data[i] = Math.min(255, data[i] * 1.05);     // Thêm đỏ
                data[i + 1] = Math.min(255, data[i + 1] * 1.03); // Thêm xanh lá
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Áp dụng bloom effect
            ctx.filter = 'brightness(1.1) contrast(1.05)';
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.filter = 'none';
        }

        // ====================== HIỂN THỊ ẢNH KẾT THÚC ======================
        function displayEndingImage(index) {
            if (!climaxSystem.imagesLoaded || index >= climaxSystem.endingImages.length) {
                return;
            }
            
            const imageContainer = document.getElementById('imageContainer');
            const imageData = climaxSystem.endingImages[index];
            
            // Xóa ảnh cũ
            while (imageContainer.firstChild && imageContainer.firstChild.classList.contains('ending-image')) {
                imageContainer.removeChild(imageContainer.firstChild);
            }
            
            // Tạo ảnh mới
            const img = new Image();
            img.src = imageData.processed;
            img.className = 'ending-image';
            
            // Đặt vị trí ngẫu nhiên nhưng cân đối
            const posX = 10 + Math.random() * 80;
            const posY = 10 + Math.random() * 80;
            
            img.style.left = `${posX}%`;
            img.style.top = `${posY}%`;
            img.style.transform = `translate(-50%, -50%) scale(0.8)`;
            
            img.onload = () => {
                imageContainer.appendChild(img);
                
                // Hiệu ứng xuất hiện
                setTimeout(() => {
                    img.classList.add('visible');
                    
                    // Hiệu ứng cuối cùng cho ảnh thứ 3
                    if (index === 2) {
                        setTimeout(() => {
                            img.classList.add('final');
                        }, 1000);
                    }
                }, 100);
                
                // Hiển thị container
                imageContainer.style.display = 'flex';
            };
        }

        function hideEndingImages() {
            const imageContainer = document.getElementById('imageContainer');
            const images = imageContainer.querySelectorAll('.ending-image');
            
            images.forEach(img => {
                img.classList.remove('visible', 'final');
            });
            
            setTimeout(() => {
                imageContainer.style.display = 'none';
                while (imageContainer.firstChild && imageContainer.firstChild.classList.contains('ending-image')) {
                    imageContainer.removeChild(imageContainer.firstChild);
                }
            }, 2500);
        }

        // ====================== HỆ THỐNG KẾT THÚC CAO TRÀO ======================
        function startFinaleSequence() {
            if (climaxSystem.isFinaleActive) return;
            
            climaxSystem.isFinaleActive = true;
            climaxSystem.finaleStep = 0;
            climaxSystem.finaleFireworks = [];
            
            // Dừng tạo pháo mới
            nextExplosionTime = Infinity;
            
            // Xóa dần các particle cũ
            setTimeout(() => {
                // Tạo 3 pháo kết thúc
                createFinalFirework(0);
                setTimeout(() => createFinalFirework(1), 800);
                setTimeout(() => createFinalFirework(2), 1600);
            }, 500);
        }

        function createFinalFirework(index) {
            const positions = [
                { x: 0.3, y: 0.4 },  // Vị trí 1
                { x: 0.5, y: 0.3 },  // Vị trí 2  
                { x: 0.7, y: 0.4 }   // Vị trí 3
            ];
            
            const pos = positions[index];
            const x = window.innerWidth * pos.x;
            const y = window.innerHeight * pos.y;
            const hue = index * 120; // Mỗi pháo một màu khác nhau
            
            // Tạo pháo đặc biệt kết thúc
            createFinalExplosion(x, y, hue, index);
            
            // Hiển thị ảnh tương ứng
            setTimeout(() => {
                displayEndingImage(index);
            }, 1500 + index * 300);
        }

        function createFinalExplosion(x, y, baseHue, index) {
            // Âm thanh đặc biệt cho pháo kết thúc
            playFinalBass(baseHue, index);
            
            // Tạo vụ nổ lớn
            createFinalExplosionCore(x, y, baseHue);
            
            // Tạo vòng tròn thứ cấp
            setTimeout(() => {
                createFinalRingExplosion(x, y, baseHue);
            }, 300);
            
            // Tạo hiệu ứng lấp lánh
            setTimeout(() => {
                createFinalSparkleEffect(x, y, baseHue);
            }, 600);
        }

        function createFinalExplosionCore(x, y, baseHue) {
            const numParticles = 200;
            const colors = [
                `hsl(${baseHue}, 100%, 85%)`,
                `hsl(${(baseHue + 60) % 360}, 100%, 80%)`,
                `hsl(${(baseHue + 120) % 360}, 100%, 75%)`
            ];
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = 8 + Math.random() * 10;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed * 0.9;
                p.life = 0;
                p.maxLife = 100 + Math.random() * 80;
                p.color = colors[Math.floor(Math.random() * colors.length)];
                p.size = (1.5 + Math.random() * 1.2) * FIREWORK_CONFIG.particleSizeMultiplier;
                p.active = true;
                p.trail = true;
                p.sparkle = true;
                p.glitter = true;
                p.gravity = 0.08;
                p.drag = 0.985;
                p.glowSize = p.size * 3.5;
                p.trailLength = 8 + Math.random() * 5;
                p.isFinal = true;
                p.fade = 0.9;
            }
        }

        function createFinalRingExplosion(x, y, baseHue) {
            const numRings = 3;
            const particlesPerRing = 80;
            
            for (let ring = 0; ring < numRings; ring++) {
                setTimeout(() => {
                    for (let i = 0; i < particlesPerRing; i++) {
                        const p = getParticle();
                        if (!p) continue;
                        
                        const angle = (Math.PI * 2 * i) / particlesPerRing;
                        const speed = 4 + ring * 1.5 + Math.random() * 2;
                        
                        p.x = x;
                        p.y = y;
                        p.vx = Math.cos(angle) * speed;
                        p.vy = Math.sin(angle) * speed;
                        p.life = 0;
                        p.maxLife = 70 + Math.random() * 50;
                        p.color = `hsl(${(baseHue + ring * 40) % 360}, 100%, ${75 - ring * 15}%)`;
                        p.size = (0.8 + Math.random() * 0.6) * FIREWORK_CONFIG.particleSizeMultiplier;
                        p.active = true;
                        p.trail = true;
                        p.gravity = 0.05;
                        p.drag = 0.99;
                        p.glowSize = p.size * 2.0;
                        p.isFinal = true;
                        p.fade = 0.8;
                    }
                }, ring * 200);
            }
        }

        function createFinalSparkleEffect(x, y, baseHue) {
            const numSparkles = 50;
            
            for (let i = 0; i < numSparkles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 100;
                const targetX = x + Math.cos(angle) * distance;
                const targetY = y + Math.sin(angle) * distance;
                
                p.x = x;
                p.y = y;
                p.vx = (targetX - x) * 0.02;
                p.vy = (targetY - y) * 0.02;
                p.life = 0;
                p.maxLife = 60 + Math.random() * 40;
                p.color = `hsl(${baseHue + Math.random() * 60 - 30}, 100%, 90%)`;
                p.size = 0.5 + Math.random() * 0.5;
                p.active = true;
                p.sparkle = true;
                p.glitter = true;
                p.gravity = 0;
                p.drag = 0.98;
                p.glowSize = p.size * 4.0;
                p.isFinal = true;
                p.fade = 1.0;
            }
        }

        // ====================== HỆ THỐNG ĐIỀU CHỈNH CAO TRÀO ======================
        function updateClimaxSystem(currentTime) {
            const elapsed = currentTime - startTime;
            const phases = FIREWORK_CONFIG.adaptiveExplosionRate.phases;
            
            if (elapsed < phases.buildup) {
                climaxSystem.phase = 'buildup';
                climaxSystem.climaxIntensity = 1.0 + (elapsed / phases.buildup) * 0.5;
                climaxSystem.soundIntensity = 1.0;
            } else if (elapsed < phases.buildup + phases.climax) {
                if (!climaxSystem.isClimaxActive) {
                    climaxSystem.isClimaxActive = true;
                    climaxSystem.phaseStartTime = currentTime;
                }
                climaxSystem.phase = 'climax';
                
                const climaxProgress = (elapsed - phases.buildup) / phases.climax;
                if (climaxProgress < 0.5) {
                    climaxSystem.climaxIntensity = 1.5 + climaxProgress * 3.0;
                } else {
                    climaxSystem.climaxIntensity = 4.0 - (climaxProgress - 0.5) * 2.5;
                }
                
                climaxSystem.soundIntensity = Math.min(2.0, 1.0 + climaxSystem.climaxIntensity * 0.3);
                climaxSystem.bassInterval = Math.max(300, 800 - climaxSystem.climaxIntensity * 150);
            } else if (elapsed < phases.buildup + phases.climax + phases.cooldown) {
                climaxSystem.phase = 'cooldown';
                const cooldownProgress = (elapsed - (phases.buildup + phases.climax)) / phases.cooldown;
                climaxSystem.climaxIntensity = Math.max(1.0, 1.5 - cooldownProgress * 0.5);
                climaxSystem.soundIntensity = Math.max(1.0, 1.5 - cooldownProgress * 0.5);
                
                // Bắt đầu kết thúc ở cuối giai đoạn cooldown
                if (cooldownProgress > 0.8 && !climaxSystem.isFinaleActive) {
                    startFinaleSequence();
                }
            } else {
                climaxSystem.phase = 'finale';
                climaxSystem.climaxIntensity = 1.0;
                climaxSystem.soundIntensity = 1.0;
                
                // Dừng mọi thứ sau khi kết thúc
                if (elapsed > phases.buildup + phases.climax + phases.cooldown + phases.finale) {
                    isRunning = false;
                    fadeMusicVolume(0.7, 0, 3);
                }
            }
            
            climaxSystem.climaxMultiplier = 1.0 / climaxSystem.climaxIntensity;
            return climaxSystem.climaxIntensity;
        }

        function getCurrentExplosionInterval() {
            const config = FIREWORK_CONFIG.adaptiveExplosionRate;
            
            if (climaxSystem.phase === 'climax') {
                const min = config.climaxRate.minInterval * climaxSystem.climaxMultiplier;
                const max = config.climaxRate.maxInterval * climaxSystem.climaxMultiplier;
                return Math.random() * (max - min) + min;
            } else {
                const min = config.normalRate.minInterval * climaxSystem.climaxMultiplier;
                const max = config.normalRate.maxInterval * climaxSystem.climaxMultiplier;
                return Math.random() * (max - min) + min;
            }
        }

        // ====================== HỆ THỐNG NHẠC NỀN ======================
        function initBackgroundMusic() {
            return new Promise((resolve, reject) => {
                try {
                    backgroundMusic = new Audio();
                    backgroundMusic.src = MUSIC_FILE;
                    backgroundMusic.loop = true;
                    backgroundMusic.volume = 0.7;
                    backgroundMusic.preload = 'auto';
                    
                    backgroundMusic.addEventListener('loadeddata', () => {
                        isMusicLoaded = true;
                        resolve(true);
                    });
                    
                    backgroundMusic.addEventListener('error', (e) => {
                        console.error("❌ Lỗi tải nhạc:", e);
                        reject(new Error("Không thể tải nhạc nền"));
                    });
                    
                    backgroundMusic.load();
                    
                } catch (e) {
                    console.error("❌ Lỗi khởi tạo nhạc:", e);
                    reject(e);
                }
            });
        }

        function playBackgroundMusic() {
            if (!backgroundMusic || !isMusicLoaded) {
                return false;
            }
            
            try {
                backgroundMusic.volume = 0;
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        fadeMusicVolume(0, 0.7, 1.5);
                    }).catch(error => {
                        console.error("❌ Lỗi phát nhạc:", error);
                    });
                }
                
                return true;
            } catch (e) {
                console.error("❌ Lỗi khi phát nhạc:", e);
                return false;
            }
        }

        function fadeMusicVolume(from, to, duration) {
            if (!backgroundMusic) return;
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            function updateVolume() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / (duration * 1000), 1);
                const currentVolume = from + (to - from) * progress;
                
                backgroundMusic.volume = Math.max(0, Math.min(1, currentVolume));
                
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }

        // ====================== HỆ THỐNG ÂM THANH ======================
        function initAudioSystem() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioCtx.createGain();
                masterGain.gain.value = SOUND_CONFIG.masterVolume;
                
                const compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -20;
                compressor.knee.value = 30;
                compressor.ratio.value = 6;
                compressor.attack.value = 0.03;
                compressor.release.value = 0.3;
                
                const lowShelf = audioCtx.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 150;
                lowShelf.gain.value = 8;
                
                masterGain.connect(lowShelf).connect(compressor).connect(audioCtx.destination);
                
                return true;
            } catch (e) {
                console.log("Audio không được hỗ trợ");
                return false;
            }
        }

        function createBassSound(frequency, type = 'sine', duration = 1.0, volume = 1.0) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.value = frequency;
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + SOUND_CONFIG.fadeInTime);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            const soundId = Symbol();
            activeSounds.add(soundId);
            
            setTimeout(() => {
                activeSounds.delete(soundId);
            }, duration * 1000);
            
            return soundId;
        }

        function createBassGlide(startFreq, endFreq, type = 'sine', duration = 1.2, volume = 0.9) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(endFreq, now + SOUND_CONFIG.frequencyBlend.glideTime);
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            return Symbol();
        }

        function createRumbleSound(duration = 0.8, baseFreq = 120, volume = 0.5) {
            const now = audioCtx.currentTime;
            
            for (let i = 0; i < 3; i++) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = baseFreq + (i * 15);
                
                gain.gain.setValueAtTime(0.001, now + (i * 0.05));
                gain.gain.exponentialRampToValueAtTime(volume * (0.7 - i * 0.2), now + (i * 0.05) + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(gain).connect(masterGain);
                osc.start(now + (i * 0.05));
                osc.stop(now + duration);
            }
            
            return Symbol();
        }

        function playFinalBass(baseHue, index) {
            const baseFreq = 25 + index * 10;
            const duration = 1.5 + index * 0.3;
            
            // Âm trầm mạnh
            createBassSound(
                baseFreq,
                'sine',
                duration,
                SOUND_CONFIG.layers.sub.weight * 2.0
            );
            
            // Âm glide
            setTimeout(() => {
                createBassGlide(
                    baseFreq * 2.0,
                    baseFreq * 0.4,
                    'sine',
                    duration * 0.8,
                    SOUND_CONFIG.layers.sub.weight * 1.2
                );
            }, 200);
            
            // Âm rung dài
            setTimeout(() => {
                createRumbleSound(
                    duration * 0.6,
                    30 + index * 15,
                    SOUND_CONFIG.layers.rumble.weight * 0.8
                );
            }, 300);
        }

        // ====================== HỆ THỐNG PHÁO HOA ======================
        function createParticlePool() {
            particles = [];
            const poolSize = particlePoolSize;
            
            for (let i = 0; i < poolSize; i++) {
                particles.push({
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 0,
                    color: '#fff',
                    size: 1.0,
                    active: false,
                    isNear: false,
                    isRocket: false,
                    isSpecial: false,
                    isFinal: false,
                    
                    trail: false,
                    sparkle: false,
                    glitter: false,
                    fade: 1.0,
                    gravity: 0.1,
                    drag: 0.98,
                    
                    glowSize: 0,
                    trailLength: 0,
                    
                    isCrossette: false,
                    crossetteTimer: 0,
                    hasExploded: false,
                    
                    isWillow: false
                });
            }
        }

        function getParticle() {
            for (let p of particles) {
                if (!p.active) return p;
            }
            
            let oldestParticle = null;
            let oldestLife = 0;
            for (let p of particles) {
                if (p.active) {
                    const lifeRatio = p.life / p.maxLife;
                    if (lifeRatio > oldestLife) {
                        oldestLife = lifeRatio;
                        oldestParticle = p;
                    }
                }
            }
            
            if (oldestParticle && oldestLife > 0.8) {
                oldestParticle.active = false;
                return oldestParticle;
            }
            
            return null;
        }

        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function renderParticle(p, ctx, progress, delta) {
            let alpha = p.isRocket ? (1 - progress ** 1.8) : (1 - progress ** 1.4);
            
            // Hiệu ứng đặc biệt cho pháo kết thúc
            if (p.isFinal) {
                alpha *= 0.9 + 0.1 * Math.sin(progress * 20 + p.life * 0.2);
            }
            
            if (p.sparkle && !p.isRocket) {
                alpha *= 0.5 + 0.5 * Math.sin(progress * 30 + p.life * 0.5);
            }
            
            if (p.glitter && !p.isRocket && progress > 0.3) {
                alpha *= 0.3 + 0.7 * Math.sin(progress * 50);
            }
            
            if (p.isNear && !p.isRocket) {
                alpha *= 1.15;
            }
            
            const fadeAlpha = p.fade !== undefined ? p.fade : 1.0;
            alpha *= fadeAlpha;
            
            if (p.glowSize && progress < 0.6) {
                const glowAlpha = alpha * (1 - progress * 1.2) * 0.8;
                ctx.shadowBlur = p.glowSize * (1 - progress * 0.5);
                ctx.shadowColor = p.color.replace(')', `, ${glowAlpha})`).replace('hsl', 'hsla');
            }
            
            if (p.trailLength && progress < 0.5 && !p.isRocket) {
                ctx.shadowBlur = p.trailLength * (1 - progress * 1.5);
                ctx.shadowColor = p.color;
            } else if (p.trail && !p.isRocket && progress < 0.4) {
                ctx.shadowBlur = (p.isNear ? 6 : 5) + Math.random() * 3;
                ctx.shadowColor = p.color;
            }
            
            ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
            ctx.beginPath();
            
            const currentSize = p.size * (p.isRocket ? 1.2 : (1 - progress * 0.4));
            ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        function animate(time) {
            if (!isRunning) return;
            requestAnimationFrame(animate);
            
            const delta = lastTime === 0 ? 1 : Math.min((time - lastTime) / (1000 / FIREWORK_CONFIG.targetFPS), 2);
            lastTime = time;

            // Cập nhật hệ thống cao trào
            const climaxIntensity = updateClimaxSystem(time);
            
            // Xóa màn hình
            let clearAlpha = climaxSystem.isFinaleActive ? 0.05 : 0.1;
            if (climaxIntensity > 2.0) {
                clearAlpha = 0.05;
            }
            
            ctx.fillStyle = `rgba(0,0,0,${clearAlpha})`;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            // Cập nhật và render particles
            ctx.save();
            for (let p of particles) {
                if (!p.active) continue;

                p.x += p.vx * delta;
                p.y += p.vy * delta;

                if (!p.isRocket) {
                    const gravity = p.gravity !== undefined ? p.gravity : 0.10;
                    const drag = p.drag !== undefined ? p.drag : 0.98;
                    
                    p.vy += gravity * delta * climaxIntensity;
                    p.vx *= drag;
                    p.vy *= drag;
                }

                p.life += delta;
                if (p.life >= p.maxLife) {
                    p.active = false;
                    continue;
                }

                const progress = p.life / p.maxLife;
                renderParticle(p, ctx, progress, delta);
            }
            ctx.restore();

            // Tạo pháo mới (trừ khi đang kết thúc)
            if (!climaxSystem.isFinaleActive && time > nextExplosionTime) {
                const interval = getCurrentExplosionInterval();
                
                let rocketCount = 1;
                if (climaxSystem.phase === 'climax') {
                    rocketCount = 1 + Math.floor(climaxIntensity / 2);
                }
                
                for (let i = 0; i < rocketCount; i++) {
                    setTimeout(() => {
                        if (isRunning) createRocket();
                    }, i * 50);
                }
                
                nextExplosionTime = time + interval;
            }
        }

        // ====================== KHỞI ĐỘNG ======================
        const btn = document.getElementById('startBtn');
        
        async function start() {
            btn.classList.add('clicked');
            
            setTimeout(async () => {
                try {
                    // Tải ảnh kết thúc trước
                    await loadEndingImages();
                    await initBackgroundMusic();
                    
                    if (!initAudioSystem()) {
                        alert("Trình duyệt không hỗ trợ Web Audio API. Vui lòng dùng Chrome/Firefox/Safari mới nhất.");
                        btn.classList.remove('clicked');
                        btn.style.visibility = 'visible';
                        return;
                    }
                    
                    playBackgroundMusic();
                    
                    initCanvas();
                    createParticlePool();

                    if (masterGain) {
                        masterGain.gain.setValueAtTime(0.001, audioCtx.currentTime);
                        masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 2.5);
                    }

                    setTimeout(() => {
                        createBassSound(30, 'sine', 2.0, 1.5);
                    }, 500);

                    isRunning = true;
                    startTime = performance.now();
                    lastTime = startTime;
                    
                    nextExplosionTime = startTime + 300;
                    nextSoundTime = startTime + 800;

                    requestAnimationFrame(animate);
                    
                } catch (error) {
                    console.error("Lỗi khởi tạo:", error);
                    alert("Có lỗi xảy ra khi khởi tạo. Vui lòng thử lại.");
                    btn.classList.remove('clicked');
                    btn.style.visibility = 'visible';
                }
            }, 800);
        }

        // ====================== EVENT LISTENERS ======================
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            start();
        }, { passive: false });
        
        btn.addEventListener('pointerdown', start);
        
        window.addEventListener('resize', () => {
            if (isRunning) initCanvas();
        });
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isRunning = false;
                pauseBackgroundMusic();
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                }
            } else if (startTime > 0) {
                isRunning = true;
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 0.5);
                }
                if (backgroundMusic && !isMusicPlaying) {
                    playBackgroundMusic();
                }
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
        
        window.addEventListener('beforeunload', () => {
            pauseBackgroundMusic();
        });
    </script>
</body>
</html>
