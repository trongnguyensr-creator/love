<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ph√°o Hoa</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: system-ui, sans-serif;
            color: #fff;
        }
        #canvas {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
        }
        
        #startBtn {
            position: relative;
            z-index: 10;
            padding: 20px 54px;
            font-size: 30px;
            font-weight: 700;
            color: #111;
            background: linear-gradient(
                135deg,
                #ffffff,
                #f3f3f3
            );
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 28px;
            cursor: pointer;
            box-shadow:
                0 10px 25px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            transition:
                transform 0.35s cubic-bezier(.22,1,.36,1),
                box-shadow 0.35s ease,
                background 0.35s ease;
            letter-spacing: 0.5px;
            animation: floatSoft 4s ease-in-out infinite;
            overflow: hidden;
        }

        #startBtn::after {
            content: "";
            position: absolute;
            top: 0;
            left: -120%;
            width: 120%;
            height: 100%;
            background: linear-gradient(
                120deg,
                transparent,
                rgba(255,255,255,0.7),
                transparent
            );
            transition: left 0.6s ease;
        }

        #startBtn:hover::after {
            left: 120%;
        }

        #startBtn:hover {
            transform: translateY(-6px);
            box-shadow:
                0 18px 40px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 1);
        }

        #startBtn:active {
            transform: scale(0.92);
            box-shadow:
                0 6px 15px rgba(0, 0, 0, 0.15);
            transition: transform 0.15s ease;
        }

        #startBtn.clicked {
            animation: fadeOutSmooth 0.9s cubic-bezier(.4,0,.2,1) forwards;
        }

        .btn-text {
            position: relative;
            z-index: 1;
            color: #111;
        }

        @keyframes floatSoft {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-8px);
            }
        }

        @keyframes fadeOutSmooth {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            40% {
                opacity: 0.8;
                transform: scale(1.05) translateY(-16px);
            }
            100% {
                opacity: 0;
                transform: scale(0.7) translateY(60px);
                visibility: hidden;
            }
        }

        /* Container cho finale image */
        #finaleContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2;
            pointer-events: none;
        }

        .finale-image-wrapper {
            position: relative;
            width: 60%;
            max-width: 700px;
            min-width: 300px;
            opacity: 0;
            transform: scale(0.7);
            transition: opacity 2s ease, transform 2s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 20px;
            overflow: hidden;
            filter: drop-shadow(0 20px 40px rgba(0, 0, 0, 0.8));
            background: transparent;
        }

        .finale-image {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 20px;
            object-fit: cover;
            aspect-ratio: 4/3;
            position: relative;
            z-index: 1;
            box-shadow: 
                0 0 80px rgba(255, 255, 255, 0.1),
                inset 0 0 100px rgba(255, 255, 255, 0.05);
        }

        /* Hi·ªáu ·ª©ng b√≥ng ƒë·ªï n√¢ng cao */
        .image-shadow {
            position: absolute;
            bottom: -30px;
            left: 10%;
            width: 80%;
            height: 60px;
            background: radial-gradient(ellipse at center, 
                rgba(0, 0, 0, 0.6) 0%, 
                rgba(0, 0, 0, 0) 70%);
            filter: blur(15px);
            z-index: 0;
            opacity: 0;
            transition: opacity 2s ease 0.5s;
        }

        /* Hi·ªáu ·ª©ng √°nh s√°ng ch·∫°y vi·ªÅn */
        .border-light {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            z-index: 2;
            pointer-events: none;
            overflow: hidden;
            opacity: 0;
        }

        .border-light::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                from 0deg,
                transparent,
                rgba(255, 255, 255, 0.8),
                rgba(255, 215, 0, 0.6),
                rgba(255, 140, 0, 0.4),
                transparent
            );
            animation: rotateLight 4s linear infinite;
        }

        .border-light::after {
            content: '';
            position: absolute;
            inset: 2px;
            background: #000;
            border-radius: 18px;
            z-index: 1;
        }

        @keyframes rotateLight {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Hi·ªáu ·ª©ng l·∫•p l√°nh */
        .sparkle-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 20px;
            z-index: 3;
            pointer-events: none;
            overflow: hidden;
            opacity: 0;
        }

        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            filter: blur(1px);
            opacity: 0;
        }

        /* Confetti particles */
        .confetti-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff6b6b;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
        }

        /* Background overlay */
        #finaleOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            z-index: 1;
            pointer-events: none;
            transition: background 3s ease;
        }

        /* Responsive styles */
        @media (max-width: 768px) {
            .finale-image-wrapper {
                width: 85%;
                max-width: 500px;
            }
            
            .finale-image {
                aspect-ratio: 3/4;
            }
        }
    </style>
</head>
<body>
    <button id="startBtn">
        <span class="btn-text">B·∫ÆT ƒê·∫¶U</span>
    </button>
    <canvas id="canvas"></canvas>
    
    <!-- Finale Section -->
    <div id="finaleOverlay"></div>
    <div id="finaleContainer">
        <div class="finale-image-wrapper">
            <img class="finale-image" id="finaleImage" src="" alt="Finale">
            <div class="image-shadow" id="imageShadow"></div>
            <div class="border-light" id="borderLight"></div>
            <div class="sparkle-overlay" id="sparkleOverlay"></div>
        </div>
    </div>

    <script>
        // C·∫§U H√åNH √ÇM THANH (CH·ªà TR·∫¶M)
        const SOUND_CONFIG = {
            masterVolume: 1.3,
            baseInterval: 1600,
            intervalVariation: 1000,
            fadeInTime: 0.2,
            fadeOutTime: 1.2,
            frequencyBlend: {
                min: 30,
                max: 80,
                glideTime: 0.6
            },
            layers: {
                sub: { weight: 1.0, freqRange: [30, 70] },
                deep: { weight: 0.7, freqRange: [20, 45] },
                rumble: { weight: 0.4, freqRange: [100, 300] }
            }
        };

        // C·∫§U H√åNH PH√ÅO HOA - V·ªöI H·ªÜ TH·ªêNG B√ôNG N·ªî SAU 10 GI√ÇY
        const FIREWORK_CONFIG = {
            maxParticlesPerExplosion: 120,
            maxIntensity: 3.0,
            
            // H·ªá th·ªëng ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô - C·∫¢I TI·∫æN
            adaptiveExplosionRate: {
                // T·ªëc ƒë·ªô b√¨nh th∆∞·ªùng
                normalRate: {
                    minInterval: 1800,
                    maxInterval: 2800
                },
                
                // T·ªëc ƒë·ªô cao tr√†o (d·ªìn d·∫≠p)
                climaxRate: {
                    minInterval: 200,      // R·∫•t nhanh
                    maxInterval: 500,      // Li√™n ti·∫øp
                    duration: 10000        // 10 gi√¢y
                },
                
                // C√°c giai ƒëo·∫°n
                phases: {
                    buildup: 10000,        // 10 gi√¢y ƒë·∫ßu - x√¢y d·ª±ng
                    climax: 10000,         // 10 gi√¢y ti·∫øp - cao tr√†o
                    finale: 15000          // 15 gi√¢y finale
                }
            },
            
            targetFPS: 60,
            maxActiveParticles: 1800,      // TƒÉng l√™n cho cao tr√†o
            particleSizeMultiplier: 0.6,
            rocketSpeedMultiplier: 0.85,
            explosionSpeedMultiplier: 0.75,
            
            // C·∫§U H√åNH KHO·∫¢NG C√ÅCH: 30% g·∫ßn, 70% xa
            distanceDistribution: {
                near: 0.3,
                far: 0.7
            },
            
            distanceSettings: {
                near: {
                    minHeight: 0.15,
                    maxHeight: 0.45,
                    sizeMultiplier: 1.3,
                    speedMultiplier: 1.15,
                    brightnessBoost: 1.2,
                    glowIntensity: 1.4
                },
                far: {
                    minHeight: 0.55,
                    maxHeight: 0.85,
                    sizeMultiplier: 0.75,
                    speedMultiplier: 0.88,
                    brightnessBoost: 0.9,
                    glowIntensity: 0.8
                }
            },
            
            // C√ÅC LO·∫†I PH√ÅO HOA - TH√äM LO·∫†I ƒê·∫∂C BI·ªÜT CHO CAO TR√ÄO
            explosionTypes: {
                normal: {
                    chrysanthemum: 0.25,
                    peony: 0.25,
                    palm: 0.15,
                    willow: 0.15,
                    ring: 0.10,
                    crossette: 0.10
                },
                climax: {
                    chrysanthemum: 0.15,
                    peony: 0.20,
                    palm: 0.10,
                    willow: 0.10,
                    ring: 0.15,
                    crossette: 0.15,
                    special: 0.15  // Lo·∫°i ƒë·∫∑c bi·ªát ch·ªâ c√≥ ·ªü cao tr√†o
                }
            },
            
            // C·∫•u h√¨nh finale - CH·ªà 1 ·∫¢NH
            finale: {
                fireworkCount: 3,
                delayBetween: 1200, // 1.2 gi√¢y gi·ªØa c√°c ph√°o
                positions: [0.5], // CH·ªà 50% width (trung t√¢m)
                fadeDuration: 2000, // 2 gi√¢y fade out particles
                imageFadeIn: 2000, // 2 gi√¢y fade in ·∫£nh
                imageScale: { from: 0.7, to: 1.0 },
                confettiCount: 50, // s·ªë confetti xung quanh ·∫£nh
                confettiColors: [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', 
                    '#96ceb4', '#ffeaa7', '#fab1a0',
                    '#a29bfe', '#fd79a8', '#fdcb6e'
                ],
                sparkleCount: 20, // s·ªë ƒëi·ªÉm l·∫•p l√°nh
                sparkleColors: [
                    '#ffffff', '#fffacd', '#f0f8ff',
                    '#e6e6fa', '#fff0f5'
                ]
            }
        };

        // ƒê∆Ø·ªúNG D·∫™N FILE NH·∫†C
        const MUSIC_FILE = 'phaobong.mp3';

        let canvas, ctx, audioCtx, masterGain, backgroundMusic;
        let particles = [];
        let particlePoolSize = FIREWORK_CONFIG.maxParticlesPerExplosion * 35; // TƒÉng pool size
        let lastTime = 0, startTime = 0;
        let isRunning = false;
        let nextExplosionTime = 0;
        let nextSoundTime = 0;
        let soundSequence = 0;
        let activeSounds = new Set();
        let isMusicLoaded = false;
        let isMusicPlaying = false;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        // H·ªá th·ªëng ƒëi·ªÅu ch·ªânh cao tr√†o
        let climaxSystem = {
            phase: 'buildup',      // buildup | climax | finale
            phaseStartTime: 0,
            climaxIntensity: 1.0,  // 1.0 = b√¨nh th∆∞·ªùng, >1.0 = cao tr√†o
            isClimaxActive: false,
            climaxMultiplier: 1.0,
            specialFireworkCounter: 0,
            
            // Hi·ªáu ·ª©ng √¢m thanh cao tr√†o
            soundIntensity: 1.0,
            lastBassTime: 0,
            bassInterval: 800
        };

        // Finale system
        let finaleSystem = {
            isActive: false,
            fireworkIndex: 0,
            finaleStartTime: 0,
            finaleFireworks: [],
            imageShown: false,
            backgroundDim: 0,
            confettiParticles: [],
            sparkles: [],
            imagePreloaded: false
        };

        // ====================== FINALE SYSTEM ======================
        
        // Preload image
        function preloadFinaleImage() {
            return new Promise((resolve) => {
                const imageUrl = '1.png'; // CH·ªà 1 ·∫¢NH
                const img = new Image();
                
                img.onload = () => {
                    document.getElementById('finaleImage').src = imageUrl;
                    finaleSystem.imagePreloaded = true;
                    resolve(true);
                };
                
                img.onerror = () => {
                    console.error(`Failed to load image: ${imageUrl}`);
                    // Use placeholder if image fails to load
                    document.getElementById('finaleImage').src = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="600" height="400" viewBox="0 0 600 400"><rect width="600" height="400" fill="%23222"/><text x="50%" y="50%" font-family="Arial" font-size="48" fill="white" text-anchor="middle" dy=".3em">FINALE</text></svg>`;
                    finaleSystem.imagePreloaded = true;
                    resolve(true);
                };
                
                img.src = imageUrl;
            });
        }

        // Create finale firework - B·∫ÆN 3 PH√ÅO ·ªû TRUNG T√ÇM
        function createFinaleFirework(positionPercent, index) {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.8) return;

            const x = window.innerWidth * positionPercent;
            const y = window.innerHeight * 0.3; // N·ªï ·ªü 30% chi·ªÅu cao
            const hue = 30 + index * 120; // M√†u s·∫Øc kh√°c nhau cho m·ªói ph√°o
            const isNear = true; // Finale fireworks lu√¥n l√† ph√°o g·∫ßn
            
            // T·∫°o v·ª• n·ªï l·ªõn ƒë·∫∑c bi·ªát
            const numParticles = Math.floor(300);
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (8 + Math.random() * 10) * FIREWORK_CONFIG.explosionSpeedMultiplier;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = 120 + Math.random() * 80; // S·ªëng l√¢u h∆°n
                p.color = `hsl(${(hue + i * 5) % 360}, 100%, 85%)`;
                p.size = (1.5 + Math.random() * 1.2) * FIREWORK_CONFIG.particleSizeMultiplier;
                p.active = true;
                p.isNear = isNear;
                p.trail = true;
                p.sparkle = true;
                p.glitter = Math.random() > 0.5;
                p.gravity = 0.06; // R∆°i ch·∫≠m h∆°n
                p.drag = 0.985;
                p.glowSize = p.size * 4.0;
                p.trailLength = 8 + Math.random() * 6;
                p.isFinale = true;
                p.finaleIndex = index;
                p.fade = 1.0; // B·∫Øt ƒë·∫ßu v·ªõi opacity ƒë·∫ßy ƒë·ªß
            }
            
            // √Çm thanh ƒë·∫∑c bi·ªát cho finale
            setTimeout(() => {
                if (audioCtx) {
                    createBassSound(
                        25 + index * 5,
                        'sine',
                        2.0,
                        SOUND_CONFIG.layers.sub.weight * 1.5
                    );
                }
            }, 200);
            
            // ƒê√°nh d·∫•u firework n√†y thu·ªôc v·ªÅ finale
            finaleSystem.finaleFireworks.push({
                index: index,
                x: x,
                y: y,
                exploded: true,
                particlesFaded: false
            });
            
            // B·∫Øt ƒë·∫ßu fade out particles sau 1 gi√¢y
            setTimeout(() => {
                fadeOutFinaleParticles(index);
            }, 1000);
        }

        // Fade out particles c·ªßa finale firework
        function fadeOutFinaleParticles(fireworkIndex) {
            let particlesFaded = 0;
            const totalParticles = particles.filter(p => p.active && p.isFinale && p.finaleIndex === fireworkIndex).length;
            
            particles.forEach(p => {
                if (p.active && p.isFinale && p.finaleIndex === fireworkIndex) {
                    // T·∫°o hi·ªáu ·ª©ng fade out
                    const fadeDuration = FIREWORK_CONFIG.finale.fadeDuration;
                    const startFade = performance.now();
                    
                    const fadeInterval = setInterval(() => {
                        const elapsed = performance.now() - startFade;
                        const progress = Math.min(elapsed / fadeDuration, 1);
                        
                        p.fade = 1.0 - progress;
                        
                        if (progress >= 1) {
                            p.active = false;
                            particlesFaded++;
                            clearInterval(fadeInterval);
                            
                            // Khi t·∫•t c·∫£ particles ƒë√£ fade, hi·ªán ·∫£nh (sau ph√°o cu·ªëi c√πng)
                            if (particlesFaded >= totalParticles * 0.9 && 
                                fireworkIndex === FIREWORK_CONFIG.finale.fireworkCount - 1) {
                                showFinaleImage();
                                finaleSystem.finaleFireworks[fireworkIndex].particlesFaded = true;
                            }
                        }
                    }, 16); // ~60fps
                }
            });
        }

        // Show image v·ªõi hi·ªáu ·ª©ng
        function showFinaleImage() {
            if (finaleSystem.imageShown) return;
            
            const wrapper = document.querySelector('.finale-image-wrapper');
            const shadow = document.getElementById('imageShadow');
            const borderLight = document.getElementById('borderLight');
            const sparkleOverlay = document.getElementById('sparkleOverlay');
            
            // Hi·ªán container finale
            document.getElementById('finaleContainer').style.display = 'flex';
            
            // Hi·ªáu ·ª©ng fade in v√† scale
            setTimeout(() => {
                wrapper.style.opacity = '1';
                wrapper.style.transform = 'scale(1)';
                
                // Hi·ªáu ·ª©ng b√≥ng ƒë·ªï
                setTimeout(() => {
                    shadow.style.opacity = '1';
                }, 500);
                
                // Hi·ªáu ·ª©ng √°nh s√°ng vi·ªÅn
                setTimeout(() => {
                    borderLight.style.opacity = '0.8';
                }, 1000);
                
                // Hi·ªáu ·ª©ng l·∫•p l√°nh
                setTimeout(() => {
                    sparkleOverlay.style.opacity = '1';
                    createSparkleEffects();
                }, 1500);
                
                // T·∫°o confetti xung quanh ·∫£nh
                createConfettiAroundImage(wrapper);
                
                finaleSystem.imageShown = true;
                
                // L√†m t·ªëi background
                dimBackground();
                
            }, 100);
        }

        // T·∫°o hi·ªáu ·ª©ng l·∫•p l√°nh
        function createSparkleEffects() {
            const sparkleOverlay = document.getElementById('sparkleOverlay');
            const colors = FIREWORK_CONFIG.finale.sparkleColors;
            
            // X√≥a sparkles c≈© n·∫øu c√≥
            finaleSystem.sparkles.forEach(sparkle => {
                if (sparkle.parentNode === sparkleOverlay) {
                    sparkleOverlay.removeChild(sparkle);
                }
            });
            finaleSystem.sparkles = [];
            
            for (let i = 0; i < FIREWORK_CONFIG.finale.sparkleCount; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                
                // Random position
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                
                sparkle.style.left = `${x}%`;
                sparkle.style.top = `${y}%`;
                sparkle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                sparkle.style.width = `${3 + Math.random() * 4}px`;
                sparkle.style.height = sparkle.style.width;
                
                sparkleOverlay.appendChild(sparkle);
                finaleSystem.sparkles.push(sparkle);
                
                // Animation sparkle
                const delay = i * 200;
                const duration = 800 + Math.random() * 800;
                
                setTimeout(() => {
                    // Sparkle in
                    sparkle.style.transition = `opacity ${duration/2}ms ease`;
                    sparkle.style.opacity = '0.9';
                    
                    // Sparkle out
                    setTimeout(() => {
                        sparkle.style.transition = `opacity ${duration/2}ms ease ${duration/2}ms`;
                        sparkle.style.opacity = '0';
                        
                        // Loop sparkle
                        setTimeout(() => {
                            if (finaleSystem.isActive) {
                                restartSparkle(sparkle);
                            }
                        }, duration);
                    }, duration/2);
                }, delay);
            }
        }

        function restartSparkle(sparkle) {
            // Random new position
            const x = Math.random() * 100;
            const y = Math.random() * 100;
            
            sparkle.style.left = `${x}%`;
            sparkle.style.top = `${y}%`;
            
            const duration = 800 + Math.random() * 800;
            
            // Sparkle in
            sparkle.style.transition = `opacity ${duration/2}ms ease`;
            sparkle.style.opacity = '0.9';
            
            // Sparkle out
            setTimeout(() => {
                sparkle.style.transition = `opacity ${duration/2}ms ease ${duration/2}ms`;
                sparkle.style.opacity = '0';
                
                // Loop sparkle
                if (finaleSystem.isActive) {
                    setTimeout(() => restartSparkle(sparkle), duration);
                }
            }, duration/2);
        }

        // T·∫°o confetti bay xung quanh ·∫£nh
        function createConfettiAroundImage(wrapper) {
            const rect = wrapper.getBoundingClientRect();
            const colors = FIREWORK_CONFIG.finale.confettiColors;
            
            for (let i = 0; i < FIREWORK_CONFIG.finale.confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti-particle';
                
                // Random starting position around image
                const side = Math.floor(Math.random() * 4);
                let startX, startY;
                
                switch(side) {
                    case 0: // top
                        startX = rect.left + Math.random() * rect.width;
                        startY = rect.top - 20;
                        break;
                    case 1: // right
                        startX = rect.right + 20;
                        startY = rect.top + Math.random() * rect.height;
                        break;
                    case 2: // bottom
                        startX = rect.left + Math.random() * rect.width;
                        startY = rect.bottom + 20;
                        break;
                    case 3: // left
                        startX = rect.left - 20;
                        startY = rect.top + Math.random() * rect.height;
                        break;
                }
                
                confetti.style.left = `${startX}px`;
                confetti.style.top = `${startY}px`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = `${6 + Math.random() * 8}px`;
                confetti.style.height = confetti.style.width;
                
                document.getElementById('finaleContainer').appendChild(confetti);
                
                // Animation confetti - bay v√†o trung t√¢m ·∫£nh
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const distance = Math.sqrt(Math.pow(startX - centerX, 2) + Math.pow(startY - centerY, 2));
                const targetX = centerX + (Math.random() - 0.5) * 100;
                const targetY = centerY + (Math.random() - 0.5) * 100;
                const duration = 1000 + Math.random() * 1000;
                const delay = i * 50;
                
                setTimeout(() => {
                    confetti.style.opacity = '1';
                    confetti.style.transition = `all ${duration}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                    confetti.style.left = `${targetX}px`;
                    confetti.style.top = `${targetY}px`;
                    
                    // Confetti ti·∫øp t·ª•c di chuy·ªÉn nh·∫π
                    setTimeout(() => {
                        const moveInterval = setInterval(() => {
                            const currentX = parseFloat(confetti.style.left);
                            const currentY = parseFloat(confetti.style.top);
                            const driftX = (Math.random() - 0.5) * 3;
                            const driftY = (Math.random() - 0.5) * 2;
                            
                            confetti.style.left = `${currentX + driftX}px`;
                            confetti.style.top = `${currentY + driftY}px`;
                        }, 100);
                        
                        // D·ª´ng confetti sau 15 gi√¢y
                        setTimeout(() => {
                            clearInterval(moveInterval);
                            confetti.style.opacity = '0';
                            setTimeout(() => {
                                if (confetti.parentNode) {
                                    confetti.parentNode.removeChild(confetti);
                                }
                            }, 1000);
                        }, 15000);
                    }, duration);
                }, delay);
                
                finaleSystem.confettiParticles.push(confetti);
            }
        }

        // L√†m t·ªëi background
        function dimBackground() {
            const overlay = document.getElementById('finaleOverlay');
            overlay.style.transition = 'background 3s ease';
            overlay.style.background = 'rgba(0, 0, 0, 0.7)';
            finaleSystem.backgroundDim = 0.7;
            
            // V·∫´n ti·∫øp t·ª•c b·∫Øn v√†i ph√°o hoa nh·ªè ·ªü xa
            setInterval(() => {
                if (isRunning && finaleSystem.isActive) {
                    createSmallBackgroundFirework();
                }
            }, 3000);
        }

        // T·∫°o ph√°o hoa nh·ªè ·ªü xa ph√≠a sau
        function createSmallBackgroundFirework() {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.6) return;

            const x = Math.random() * window.innerWidth;
            const y = window.innerHeight * (0.7 + Math.random() * 0.2); // ·ªû xa ph√≠a tr√™n
            const hue = Math.random() * 360;
            const isNear = false; // Ph√°o xa
            
            // T·∫°o v·ª• n·ªï nh·ªè
            const numParticles = Math.floor(40 + Math.random() * 30);
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (3 + Math.random() * 3) * FIREWORK_CONFIG.explosionSpeedMultiplier;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = 60 + Math.random() * 40;
                p.color = `hsl(${hue}, 70%, 60%)`;
                p.size = (0.8 + Math.random() * 0.6) * FIREWORK_CONFIG.particleSizeMultiplier;
                p.active = true;
                p.isNear = isNear;
                p.trail = false;
                p.gravity = 0.08;
                p.drag = 0.98;
                p.glowSize = p.size * 1.5;
                p.isBackground = true;
                p.fade = 0.5; // M·ªù h∆°n
            }
        }

        // B·∫Øt ƒë·∫ßu giai ƒëo·∫°n finale
        function startFinalePhase() {
            if (finaleSystem.isActive) return;
            
            console.log("üéá B·∫Øt ƒë·∫ßu giai ƒëo·∫°n FINALE!");
            finaleSystem.isActive = true;
            finaleSystem.finaleStartTime = performance.now();
            finaleSystem.fireworkIndex = 0;
            finaleSystem.finaleFireworks = [];
            finaleSystem.imageShown = false;
            
            // ƒê·∫£m b·∫£o image ƒë√£ preload
            if (!finaleSystem.imagePreloaded) {
                preloadFinaleImage();
            }
            
            // B·∫Øn 3 qu·∫£ ph√°o finale ·ªü TRUNG T√ÇM c√°ch nhau 1-1.5 gi√¢y
            function launchNextFinaleFirework() {
                if (finaleSystem.fireworkIndex < FIREWORK_CONFIG.finale.fireworkCount) {
                    // T·∫§T C·∫¢ ·ªû V·ªä TR√ç 50% (trung t√¢m)
                    createFinaleFirework(0.5, finaleSystem.fireworkIndex);
                    
                    finaleSystem.fireworkIndex++;
                    
                    if (finaleSystem.fireworkIndex < FIREWORK_CONFIG.finale.fireworkCount) {
                        const delay = FIREWORK_CONFIG.finale.delayBetween + Math.random() * 300;
                        setTimeout(launchNextFinaleFirework, delay);
                    }
                }
            }
            
            // B·∫Øt ƒë·∫ßu b·∫Øn ph√°o finale
            setTimeout(launchNextFinaleFirework, 500);
        }

        // ====================== H·ªÜ TH·ªêNG ƒêI·ªÄU CH·ªàNH CAO TR√ÄO ======================
        function updateClimaxSystem(currentTime) {
            const elapsed = currentTime - startTime;
            
            // X√°c ƒë·ªãnh phase hi·ªán t·∫°i
            const phases = FIREWORK_CONFIG.adaptiveExplosionRate.phases;
            
            if (elapsed < phases.buildup) {
                // Phase 1: X√¢y d·ª±ng (0-10 gi√¢y)
                climaxSystem.phase = 'buildup';
                climaxSystem.climaxIntensity = 1.0 + (elapsed / phases.buildup) * 0.5;
                climaxSystem.soundIntensity = 1.0;
            } else if (elapsed < phases.buildup + phases.climax) {
                // Phase 2: Cao tr√†o (10-20 gi√¢y)
                if (!climaxSystem.isClimaxActive) {
                    climaxSystem.isClimaxActive = true;
                    climaxSystem.phaseStartTime = currentTime;
                }
                climaxSystem.phase = 'climax';
                
                const climaxProgress = (elapsed - phases.buildup) / phases.climax;
                if (climaxProgress < 0.5) {
                    climaxSystem.climaxIntensity = 1.5 + climaxProgress * 3.0;
                } else {
                    climaxSystem.climaxIntensity = 4.0 - (climaxProgress - 0.5) * 2.5;
                }
                
                climaxSystem.soundIntensity = Math.min(2.0, 1.0 + climaxSystem.climaxIntensity * 0.3);
                climaxSystem.bassInterval = Math.max(300, 800 - climaxSystem.climaxIntensity * 150);
            } else if (elapsed < phases.buildup + phases.climax + phases.finale) {
                // Phase 3: Finale (20-35 gi√¢y)
                if (climaxSystem.phase !== 'finale') {
                    climaxSystem.phase = 'finale';
                    // B·∫Øt ƒë·∫ßu finale phase
                    if (!finaleSystem.isActive) {
                        startFinalePhase();
                    }
                }
                
                // Gi·∫£m d·∫ßn intensity
                const finaleProgress = (elapsed - (phases.buildup + phases.climax)) / phases.finale;
                climaxSystem.climaxIntensity = Math.max(0.5, 1.5 - finaleProgress * 1.0);
                climaxSystem.soundIntensity = Math.max(0.5, 1.5 - finaleProgress * 1.0);
            } else {
                // K·∫øt th√∫c
                climaxSystem.phase = 'ended';
                climaxSystem.climaxIntensity = 0.3;
                climaxSystem.soundIntensity = 0.3;
            }
            
            climaxSystem.climaxMultiplier = 1.0 / climaxSystem.climaxIntensity;
            
            return climaxSystem.climaxIntensity;
        }

        // ====================== C√ÅC H√ÄM C≈® (GI·ªÆ NGUY√äN) ======================
        
        function getCurrentExplosionInterval() {
            const config = FIREWORK_CONFIG.adaptiveExplosionRate;
            
            if (climaxSystem.phase === 'climax') {
                const min = config.climaxRate.minInterval * climaxSystem.climaxMultiplier;
                const max = config.climaxRate.maxInterval * climaxSystem.climaxMultiplier;
                return Math.random() * (max - min) + min;
            } else if (climaxSystem.phase === 'finale') {
                // ·ªû finale, gi·∫£m t·∫ßn su·∫•t ph√°o hoa ch√≠nh
                return Math.random() * 2000 + 1500;
            } else {
                const min = config.normalRate.minInterval * climaxSystem.climaxMultiplier;
                const max = config.normalRate.maxInterval * climaxSystem.climaxMultiplier;
                return Math.random() * (max - min) + min;
            }
        }

        function getExplosionTypeForPhase() {
            if (climaxSystem.phase === 'climax') {
                const rand = Math.random();
                let cumulative = 0;
                
                for (let [type, probability] of Object.entries(FIREWORK_CONFIG.explosionTypes.climax)) {
                    cumulative += probability;
                    if (rand <= cumulative) {
                        return type;
                    }
                }
            }
            
            const rand = Math.random();
            let cumulative = 0;
            
            for (let [type, probability] of Object.entries(FIREWORK_CONFIG.explosionTypes.normal)) {
                cumulative += probability;
                if (rand <= cumulative) {
                    return type;
                }
            }
            
            return 'peony';
        }

        function initBackgroundMusic() {
            return new Promise((resolve, reject) => {
                try {
                    backgroundMusic = new Audio();
                    backgroundMusic.src = MUSIC_FILE;
                    backgroundMusic.loop = true;
                    backgroundMusic.volume = 0.7;
                    backgroundMusic.preload = 'auto';
                    
                    backgroundMusic.addEventListener('loadeddata', () => {
                        isMusicLoaded = true;
                        resolve(true);
                    });
                    
                    backgroundMusic.addEventListener('error', (e) => {
                        console.error("‚ùå L·ªói t·∫£i nh·∫°c:", e);
                        reject(new Error("Kh√¥ng th·ªÉ t·∫£i nh·∫°c n·ªÅn"));
                    });
                    
                    backgroundMusic.load();
                    
                } catch (e) {
                    console.error("‚ùå L·ªói kh·ªüi t·∫°o nh·∫°c:", e);
                    reject(e);
                }
            });
        }

        function playBackgroundMusic() {
            if (!backgroundMusic || !isMusicLoaded) {
                return false;
            }
            
            try {
                backgroundMusic.volume = 0;
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        fadeMusicVolume(0, 0.7, 1.5);
                    }).catch(error => {
                        console.error("‚ùå L·ªói ph√°t nh·∫°c:", error);
                    });
                }
                
                return true;
            } catch (e) {
                console.error("‚ùå L·ªói khi ph√°t nh·∫°c:", e);
                return false;
            }
        }

        function fadeMusicVolume(from, to, duration) {
            if (!backgroundMusic) return;
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            function updateVolume() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / (duration * 1000), 1);
                const currentVolume = from + (to - from) * progress;
                
                backgroundMusic.volume = Math.max(0, Math.min(1, currentVolume));
                
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }

        function pauseBackgroundMusic() {
            if (backgroundMusic && isMusicPlaying) {
                backgroundMusic.pause();
                isMusicPlaying = false;
            }
        }

        function initAudioSystem() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioCtx.createGain();
                masterGain.gain.value = SOUND_CONFIG.masterVolume;
                
                const compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -20;
                compressor.knee.value = 30;
                compressor.ratio.value = 6;
                compressor.attack.value = 0.03;
                compressor.release.value = 0.3;
                
                const lowShelf = audioCtx.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 150;
                lowShelf.gain.value = 8;
                
                masterGain.connect(lowShelf).connect(compressor).connect(audioCtx.destination);
                
                return true;
            } catch (e) {
                console.log("Audio kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£");
                return false;
            }
        }

        function createBassSound(frequency, type = 'sine', duration = 1.0, volume = 1.0) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.value = frequency;
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + SOUND_CONFIG.fadeInTime);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            const soundId = Symbol();
            activeSounds.add(soundId);
            
            setTimeout(() => {
                activeSounds.delete(soundId);
            }, duration * 1000);
            
            return soundId;
        }

        function createBassGlide(startFreq, endFreq, type = 'sine', duration = 1.2, volume = 0.9) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(endFreq, now + SOUND_CONFIG.frequencyBlend.glideTime);
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            return Symbol();
        }

        function createRumbleSound(duration = 0.8, baseFreq = 120, volume = 0.5) {
            const now = audioCtx.currentTime;
            
            for (let i = 0; i < 3; i++) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = baseFreq + (i * 15);
                
                gain.gain.setValueAtTime(0.001, now + (i * 0.05));
                gain.gain.exponentialRampToValueAtTime(volume * (0.7 - i * 0.2), now + (i * 0.05) + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(gain).connect(masterGain);
                osc.start(now + (i * 0.05));
                osc.stop(now + duration);
            }
            
            return Symbol();
        }

        function playDeepBass() {
            const baseFreq = 35 + Math.random() * 20 * climaxSystem.soundIntensity;
            const volume = SOUND_CONFIG.layers.sub.weight * climaxSystem.soundIntensity;
            
            createBassSound(
                baseFreq,
                'sine',
                1.4,
                volume
            );
            
            setTimeout(() => {
                createBassSound(
                    baseFreq * 0.5,
                    'sine',
                    1.6,
                    SOUND_CONFIG.layers.deep.weight * 0.6 * climaxSystem.soundIntensity
                );
            }, 200);
            
            setTimeout(() => {
                createRumbleSound(
                    0.6,
                    80 + Math.random() * 40,
                    SOUND_CONFIG.layers.rumble.weight * 0.3 * climaxSystem.soundIntensity
                );
            }, 150);
        }

        function playBassGlide() {
            const startFreq = 50 + Math.random() * 20 * climaxSystem.soundIntensity;
            const endFreq = startFreq * 0.6;
            
            createBassGlide(
                startFreq,
                endFreq,
                'sine',
                1.3,
                SOUND_CONFIG.layers.sub.weight * 0.9 * climaxSystem.soundIntensity
            );
            
            setTimeout(() => {
                createBassSound(
                    startFreq * 1.5,
                    'sine',
                    1.0,
                    SOUND_CONFIG.layers.sub.weight * 0.4 * climaxSystem.soundIntensity
                );
            }, 300);
        }

        function playDualBass() {
            const freq1 = 40 + Math.random() * 15 * climaxSystem.soundIntensity;
            const freq2 = 55 + Math.random() * 20 * climaxSystem.soundIntensity;
            
            createBassSound(
                freq1,
                'sine',
                1.2,
                SOUND_CONFIG.layers.sub.weight * 0.8 * climaxSystem.soundIntensity
            );
            
            setTimeout(() => {
                createBassSound(
                    freq2,
                    'sine',
                    1.1,
                    SOUND_CONFIG.layers.sub.weight * 0.7 * climaxSystem.soundIntensity
                );
            }, 100);
            
            setTimeout(() => {
                createBassSound(
                    Math.min(freq1, freq2) * 0.4,
                    'sine',
                    1.5,
                    SOUND_CONFIG.layers.deep.weight * 0.5 * climaxSystem.soundIntensity
                );
            }, 250);
        }

        function playPowerBass() {
            const now = Date.now();
            const timeFactor = Math.sin(now * 0.001) * 0.5 + 0.5;
            
            const mainFreq = 30 + timeFactor * 20 * climaxSystem.soundIntensity;
            createBassSound(
                mainFreq,
                'sine',
                1.6,
                SOUND_CONFIG.layers.sub.weight * (0.9 + timeFactor * 0.3) * climaxSystem.soundIntensity
            );
            
            setTimeout(() => {
                createBassSound(
                    mainFreq * 0.75,
                    'sine',
                    1.4,
                    SOUND_CONFIG.layers.deep.weight * 0.6 * climaxSystem.soundIntensity
                );
                
                createBassSound(
                    mainFreq * 0.6,
                    'sine',
                    1.5,
                    SOUND_CONFIG.layers.deep.weight * 0.4 * climaxSystem.soundIntensity
                );
            }, 150);
            
            setTimeout(() => {
                createRumbleSound(
                    0.9,
                    60 + Math.random() * 30,
                    SOUND_CONFIG.layers.rumble.weight * 0.5 * climaxSystem.soundIntensity
                );
            }, 200);
        }

        function playClimaxBass() {
            const baseFreq = 25 + Math.random() * 30 * climaxSystem.soundIntensity;
            const duration = 0.8 + Math.random() * 0.4;
            
            createBassSound(
                baseFreq,
                'sine',
                duration,
                SOUND_CONFIG.layers.sub.weight * climaxSystem.soundIntensity * 1.5
            );
            
            setTimeout(() => {
                createRumbleSound(
                    duration * 0.7,
                    40 + Math.random() * 30,
                    SOUND_CONFIG.layers.rumble.weight * climaxSystem.soundIntensity * 0.8
                );
            }, 50);
            
            setTimeout(() => {
                createBassGlide(
                    baseFreq * 1.8,
                    baseFreq * 0.4,
                    'sine',
                    duration * 1.2,
                    SOUND_CONFIG.layers.sub.weight * climaxSystem.soundIntensity * 0.7
                );
            }, 100);
        }

        function playBassSound(isNear = false) {
            if (!audioCtx || activeSounds.size > 6) return;
            
            const currentTime = performance.now();
            if (climaxSystem.phase === 'climax' && 
                currentTime - climaxSystem.lastBassTime > climaxSystem.bassInterval) {
                climaxSystem.lastBassTime = currentTime;
                
                if (Math.random() > 0.5) {
                    playClimaxBass();
                } else {
                    soundSequence = (soundSequence + 1) % 4;
                    switch(soundSequence) {
                        case 0: playDeepBass(); break;
                        case 1: playBassGlide(); break;
                        case 2: playDualBass(); break;
                        case 3: playPowerBass(); break;
                    }
                }
            } else if (currentTime > nextSoundTime) {
                soundSequence = (soundSequence + 1) % 4;
                switch(soundSequence) {
                    case 0: playDeepBass(); break;
                    case 1: playBassGlide(); break;
                    case 2: playDualBass(); break;
                    case 3: playPowerBass(); break;
                }
                
                const variation = (Math.random() - 0.5) * SOUND_CONFIG.intervalVariation;
                nextSoundTime = currentTime + SOUND_CONFIG.baseInterval + variation;
            }
        }

        function createParticlePool() {
            particles = [];
            const poolSize = particlePoolSize;
            
            for (let i = 0; i < poolSize; i++) {
                particles.push({
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 0,
                    color: '#fff',
                    size: 1.0,
                    active: false,
                    isNear: false,
                    isRocket: false,
                    isSpecial: false,
                    isFinale: false,
                    finaleIndex: -1,
                    isBackground: false,
                    
                    trail: false,
                    sparkle: false,
                    glitter: false,
                    fade: 1.0,
                    gravity: 0.1,
                    drag: 0.98,
                    
                    glowSize: 0,
                    trailLength: 0,
                    
                    isCrossette: false,
                    crossetteTimer: 0,
                    hasExploded: false,
                    
                    isWillow: false
                });
            }
        }

        function getParticle() {
            for (let p of particles) {
                if (!p.active) return p;
            }
            
            let oldestParticle = null;
            let oldestLife = 0;
            for (let p of particles) {
                if (p.active) {
                    const lifeRatio = p.life / p.maxLife;
                    if (lifeRatio > oldestLife) {
                        oldestLife = lifeRatio;
                        oldestParticle = p;
                    }
                }
            }
            
            if (oldestParticle && oldestLife > 0.8) {
                oldestParticle.active = false;
                return oldestParticle;
            }
            
            return null;
        }

        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function countActiveParticles() {
            let count = 0;
            for (let p of particles) {
                if (p.active) count++;
            }
            return count;
        }

        function createRocket() {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.95) return;

            const isNear = Math.random() < FIREWORK_CONFIG.distanceDistribution.near;
            const settings = FIREWORK_CONFIG.distanceSettings[isNear ? 'near' : 'far'];
            
            let adjustedNearProb = FIREWORK_CONFIG.distanceDistribution.near;
            if (climaxSystem.phase === 'climax') {
                adjustedNearProb = 0.5;
            }
            
            const finalIsNear = Math.random() < adjustedNearProb;
            const finalSettings = finalIsNear ? settings : FIREWORK_CONFIG.distanceSettings.far;
            
            const x = Math.random() * window.innerWidth;
            const yStart = window.innerHeight;
            const hue = Math.random() * 360;

            const p = getParticle();
            if (p) {
                p.x = x;
                p.y = yStart;
                p.vx = (Math.random() - 0.5) * 1.8 * climaxSystem.climaxIntensity;
                p.vy = -(13 + Math.random() * 7) * FIREWORK_CONFIG.rocketSpeedMultiplier * finalSettings.speedMultiplier * climaxSystem.climaxIntensity;
                p.life = 0;
                p.maxLife = 55 + Math.random() * 25;
                p.color = `hsl(${hue}, 100%, ${finalIsNear ? 90 : 80}%)`;
                p.size = (1.8 + Math.random() * 1.0) * FIREWORK_CONFIG.particleSizeMultiplier * finalSettings.sizeMultiplier * climaxSystem.climaxIntensity;
                p.active = true;
                p.isRocket = true;
                p.isNear = finalIsNear;
                p.trailHue = hue;
                p.glowSize = p.size * 3.0 * climaxSystem.climaxIntensity;
                p.trailLength = (finalIsNear ? 10 : 8) * climaxSystem.climaxIntensity;
                p.isSpecial = climaxSystem.phase === 'climax' && Math.random() > 0.7;
            }

            const trailFrequency = Math.max(30, 60 / climaxSystem.climaxIntensity);
            let trailInterval = setInterval(() => {
                if (!isRunning || !p || !p.active) {
                    clearInterval(trailInterval);
                    return;
                }
                
                const trailCount = climaxSystem.phase === 'climax' ? 2 + Math.floor(Math.random() * 2) : 1;
                
                for (let i = 0; i < trailCount; i++) {
                    const trail = getParticle();
                    if (trail) {
                        trail.x = p.x + (Math.random() - 0.5) * 3;
                        trail.y = p.y + (Math.random() - 0.5) * 3;
                        trail.vx = p.vx * 0.2 + (Math.random() - 0.5) * 0.8;
                        trail.vy = p.vy * 0.1 + Math.random() * 1.5;
                        trail.life = 0;
                        trail.maxLife = 20 + Math.random() * 20;
                        trail.color = `hsl(${hue}, 80%, 70%)`;
                        trail.size = p.size * 0.6;
                        trail.active = true;
                        trail.fade = 0.8;
                        trail.drag = 0.94;
                    }
                }
            }, trailFrequency);

            setTimeout(() => {
                if (!isRunning) return;
                clearInterval(trailInterval);
                
                const minHeight = finalSettings.minHeight * window.innerHeight;
                const maxHeight = finalSettings.maxHeight * window.innerHeight;
                const yExplode = minHeight + Math.random() * (maxHeight - minHeight);
                
                const explosionType = getExplosionTypeForPhase();
                
                createExplosion(x, yExplode, hue, finalIsNear, explosionType);
                
                if (climaxSystem.phase === 'climax' || Math.random() > 0.6) {
                    playBassSound(finalIsNear);
                }
            }, (finalIsNear ? 700 : 900) + Math.random() * 600 / climaxSystem.climaxIntensity);
        }

        function createSpecialExplosion(x, y, baseHue, isNear) {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.9) return;

            const settings = FIREWORK_CONFIG.distanceSettings[isNear ? 'near' : 'far'];
            const numParticles = Math.floor(200 * climaxSystem.climaxIntensity);
            
            const colorCount = 3 + Math.floor(Math.random() * 3);
            const colors = [];
            for (let i = 0; i < colorCount; i++) {
                colors.push(`hsl(${(baseHue + i * 120) % 360}, 100%, ${isNear ? 80 : 70}%)`);
            }
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (6 + Math.random() * 8) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed * 0.9;
                p.life = 0;
                p.maxLife = (isNear ? 90 : 80) + Math.random() * 60;
                p.color = colors[Math.floor(Math.random() * colors.length)];
                p.size = (1.2 + Math.random() * 1.0) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                p.active = true;
                p.isNear = isNear;
                p.trail = true;
                p.sparkle = true;
                p.glitter = true;
                p.gravity = 0.12;
                p.drag = 0.97;
                p.glowSize = p.size * 3.0 * climaxSystem.climaxIntensity;
                p.trailLength = (isNear ? 6 : 5) + Math.random() * 4;
                p.isSpecial = true;
            }
            
            setTimeout(() => {
                if (!isRunning) return;
                for (let i = 0; i < numParticles * 0.3; i++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 4 + Math.random() * 3;
                    
                    p.x = x + (Math.random() - 0.5) * 100;
                    p.y = y + (Math.random() - 0.5) * 100;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = 40 + Math.random() * 30;
                    p.color = `hsl(${(baseHue + 180) % 360}, 100%, 70%)`;
                    p.size = 0.8 + Math.random() * 0.6;
                    p.active = true;
                    p.isNear = isNear;
                    p.sparkle = true;
                    p.gravity = 0.15;
                    p.drag = 0.95;
                }
            }, 300);
        }

        function createExplosion(x, y, baseHue, isNear, type = 'peony') {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.9) return;

            const settings = FIREWORK_CONFIG.distanceSettings[isNear ? 'near' : 'far'];
            
            if (type === 'special') {
                createSpecialExplosion(x, y, baseHue, isNear);
                return;
            }
            
            const intensityMultiplier = climaxSystem.climaxIntensity;
            const particleMultiplier = 0.8 + intensityMultiplier * 0.4;
            
            switch(type) {
                case 'chrysanthemum':
                    createChrysanthemumExplosion(x, y, baseHue, isNear, settings, particleMultiplier);
                    break;
                case 'peony':
                    createPeonyExplosion(x, y, baseHue, isNear, settings, particleMultiplier);
                    break;
                case 'palm':
                    createPalmExplosion(x, y, baseHue, isNear, settings, particleMultiplier);
                    break;
                case 'willow':
                    createWillowExplosion(x, y, baseHue, isNear, settings, particleMultiplier);
                    break;
                case 'ring':
                    createRingExplosion(x, y, baseHue, isNear, settings, particleMultiplier);
                    break;
                case 'crossette':
                    createCrossetteExplosion(x, y, baseHue, isNear, settings, particleMultiplier);
                    break;
                default:
                    createPeonyExplosion(x, y, baseHue, isNear, settings, particleMultiplier);
            }
        }

        function createChrysanthemumExplosion(x, y, baseHue, isNear, settings, multiplier = 1.0) {
            const rays = Math.floor((25 + Math.random() * 20) * multiplier);
            const particlesPerRay = Math.floor((8 + Math.random() * 6) * multiplier);
            
            for (let i = 0; i < rays; i++) {
                const angle = (Math.PI * 2 * i) / rays;
                
                for (let j = 0; j < particlesPerRay; j++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const speed = (6 + j * 0.8 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = (isNear ? 75 : 65) + Math.random() * 40;
                    
                    const hueShift = (Math.random() - 0.5) * 30;
                    const brightness = (isNear ? 70 : 60) + Math.random() * 25;
                    p.color = `hsl(${baseHue + hueShift}, 100%, ${brightness}%)`;
                    
                    p.size = (0.9 + Math.random() * 0.8) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                    p.active = true;
                    p.isNear = isNear;
                    p.trail = true;
                    p.trailLength = (isNear ? 5 : 4) + Math.random() * 3;
                    p.sparkle = j % 3 === 0;
                    p.gravity = 0.08;
                    p.drag = 0.985;
                    p.glowSize = p.size * (isNear ? 2.5 : 2.0) * climaxSystem.climaxIntensity;
                }
            }
        }

        function createPeonyExplosion(x, y, baseHue, isNear, settings, multiplier = 1.0) {
            const numParticles = Math.floor(((isNear ? 120 : 100) + Math.random() * 80) * multiplier);
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (3 + Math.random() * 4) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = (isNear ? 80 : 70) + Math.random() * 60;
                p.color = `hsl(${baseHue}, 100%, ${(isNear ? 80 : 70) + Math.random() * 20}%)`;
                p.size = (1.2 + Math.random() * 0.8) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                p.active = true;
                p.isNear = isNear;
                p.trail = true;
                p.glitter = Math.random() > 0.6;
                p.gravity = 0.09;
                p.drag = 0.98;
                p.glowSize = p.size * (isNear ? 2.8 : 2.3) * climaxSystem.climaxIntensity;
            }
        }

        function createPalmExplosion(x, y, baseHue, isNear, settings, multiplier = 1.0) {
            const numStreamers = Math.floor((8 + Math.random() * 6) * multiplier);
            
            for (let i = 0; i < numStreamers; i++) {
                const angle = (Math.PI * 2 * i) / numStreamers + (Math.random() - 0.5) * 0.5;
                const streamerLength = Math.floor((20 + Math.random() * 15) * multiplier);
                
                for (let j = 0; j < streamerLength; j++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const speed = (12 + j * 0.3 + Math.random() * 3) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = (isNear ? 100 : 90) + Math.random() * 50;
                    p.color = `hsl(${baseHue}, 100%, ${(isNear ? 75 : 65) - j * 1.5}%)`;
                    p.size = (1.0 + Math.random() * 0.7) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                    p.active = true;
                    p.isNear = isNear;
                    p.trail = true;
                    p.trailLength = (isNear ? 8 : 6) + Math.random() * 4;
                    p.gravity = 0.05;
                    p.drag = 0.99;
                    p.glowSize = p.size * (isNear ? 3.0 : 2.5) * climaxSystem.climaxIntensity;
                }
            }
        }

        function createWillowExplosion(x, y, baseHue, isNear, settings, multiplier = 1.0) {
            const numParticles = Math.floor(((isNear ? 80 : 70) + Math.random() * 60) * multiplier);
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (2 + Math.random() * 3) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = (isNear ? 150 : 130) + Math.random() * 80;
                p.color = `hsl(${baseHue}, 70%, ${(isNear ? 65 : 55) + Math.random() * 20}%)`;
                p.size = (0.8 + Math.random() * 0.6) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                p.active = true;
                p.isNear = isNear;
                p.isWillow = true;
                p.gravity = 0.03;
                p.drag = 0.995;
                p.sparkle = Math.random() > 0.7;
                p.glowSize = p.size * (isNear ? 2.0 : 1.7) * climaxSystem.climaxIntensity;
            }
        }

        function createRingExplosion(x, y, baseHue, isNear, settings, multiplier = 1.0) {
            const rings = 3 + Math.floor(Math.random() * 3);
            const particlesPerRing = Math.floor((25 + Math.random() * 20) * multiplier);
            
            for (let ring = 0; ring < rings; ring++) {
                const radius = (ring + 1) * 1.5;
                
                for (let i = 0; i < particlesPerRing; i++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const angle = (Math.PI * 2 * i) / particlesPerRing;
                    const speed = (4 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                    
                    p.x = x + Math.cos(angle) * radius * 8;
                    p.y = y + Math.sin(angle) * radius * 8;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = (isNear ? 70 : 60) + Math.random() * 40;
                    p.color = `hsl(${(baseHue + ring * 40) % 360}, 100%, ${(isNear ? 75 : 65) + Math.random() * 20}%)`;
                    p.size = (1.0 + Math.random() * 0.6) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                    p.active = true;
                    p.isNear = isNear;
                    p.trail = true;
                    p.trailLength = (isNear ? 4 : 3) + Math.random() * 3;
                    p.gravity = 0.07;
                    p.drag = 0.987;
                    p.glowSize = p.size * (isNear ? 2.2 : 1.8) * climaxSystem.climaxIntensity;
                }
            }
        }

        function createCrossetteExplosion(x, y, baseHue, isNear, settings, multiplier = 1.0) {
            const numClusters = Math.floor((6 + Math.random() * 5) * multiplier);
            
            for (let cluster = 0; cluster < numClusters; cluster++) {
                const clusterAngle = Math.random() * Math.PI * 2;
                const clusterSpeed = (5 + Math.random() * 3) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                const clusterX = x + Math.cos(clusterAngle) * 10;
                const clusterY = y + Math.sin(clusterAngle) * 10;
                
                setTimeout(() => {
                    const numParticles = Math.floor((12 + Math.random() * 8) * multiplier);
                    
                    for (let i = 0; i < numParticles; i++) {
                        const p = getParticle();
                        if (!p) continue;
                        
                        const angle = Math.random() * Math.PI * 2;
                        const speed = (3 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                        
                        p.x = clusterX;
                        p.y = clusterY;
                        p.vx = Math.cos(angle) * speed;
                        p.vy = Math.sin(angle) * speed;
                        p.life = 0;
                        p.maxLife = (isNear ? 50 : 40) + Math.random() * 30;
                        p.color = `hsl(${baseHue}, 100%, ${(isNear ? 80 : 70) + Math.random() * 20}%)`;
                        p.size = (0.9 + Math.random() * 0.5) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                        p.active = true;
                        p.isNear = isNear;
                        p.trail = true;
                        p.trailLength = (isNear ? 3 : 2) + Math.random() * 2;
                        p.sparkle = true;
                        p.gravity = 0.1;
                        p.drag = 0.975;
                        p.isCrossette = true;
                        p.crossetteTimer = 15 + Math.random() * 10;
                        p.hasExploded = false;
                        p.glowSize = p.size * (isNear ? 2.0 : 1.6) * climaxSystem.climaxIntensity;
                    }
                }, cluster * 80);
            }
        }

        function renderParticle(p, ctx, progress, delta) {
            let alpha = p.fade !== undefined ? p.fade : 1.0;
            
            if (!p.isFinale) {
                alpha *= p.isRocket ? (1 - progress ** 1.8) : (1 - progress ** 1.4);
                
                if (climaxSystem.phase === 'climax') {
                    alpha *= 1.2;
                }
                
                if (p.isSpecial) {
                    alpha *= 0.8 + 0.4 * Math.sin(progress * 40 + p.life * 0.3);
                }
                
                if (p.sparkle && !p.isRocket) {
                    alpha *= 0.5 + 0.5 * Math.sin(progress * 30 + p.life * 0.5);
                }
                
                if (p.glitter && !p.isRocket && progress > 0.3) {
                    alpha *= 0.3 + 0.7 * Math.sin(progress * 50);
                }
                
                if (p.isNear && !p.isRocket) {
                    alpha *= 1.15;
                }
            }
            
            if (p.isBackground) {
                alpha *= 0.5;
            }
            
            if (p.glowSize && progress < 0.6) {
                const glowAlpha = alpha * (1 - progress * 1.2) * 0.8;
                ctx.shadowBlur = p.glowSize * (1 - progress * 0.5);
                ctx.shadowColor = p.color.replace(')', `, ${glowAlpha})`).replace('hsl', 'hsla');
            }
            
            if (p.trailLength && progress < 0.5 && !p.isRocket) {
                ctx.shadowBlur = p.trailLength * (1 - progress * 1.5);
                ctx.shadowColor = p.color;
            } else if (p.trail && !p.isRocket && progress < 0.4) {
                ctx.shadowBlur = (p.isNear ? 6 : 5) + Math.random() * 3;
                ctx.shadowColor = p.color;
            }
            
            ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
            ctx.beginPath();
            
            const currentSize = p.size * (p.isRocket ? 1.2 : (1 - progress * 0.4));
            ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        function animate(time) {
            if (!isRunning) return;
            requestAnimationFrame(animate);
            
            const delta = lastTime === 0 ? 1 : Math.min((time - lastTime) / (1000 / FIREWORK_CONFIG.targetFPS), 2);
            lastTime = time;

            const climaxIntensity = updateClimaxSystem(time);
            
            let clearAlpha = 0.1;
            if (climaxIntensity > 2.0) {
                clearAlpha = 0.05;
            }
            
            if (finaleSystem.backgroundDim > 0) {
                clearAlpha = Math.max(0.02, clearAlpha * (1 - finaleSystem.backgroundDim));
            }
            
            ctx.fillStyle = `rgba(0,0,0,${clearAlpha})`;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            playBassSound();

            ctx.save();
            for (let p of particles) {
                if (!p.active) continue;

                p.x += p.vx * delta;
                p.y += p.vy * delta;

                if (!p.isRocket) {
                    const gravity = p.gravity !== undefined ? p.gravity : 0.10;
                    const drag = p.drag !== undefined ? p.drag : 0.98;
                    
                    p.vy += gravity * delta * climaxIntensity;
                    p.vx *= drag;
                    p.vy *= drag;
                }

                p.life += delta;
                if (p.life >= p.maxLife) {
                    p.active = false;
                    continue;
                }

                const progress = p.life / p.maxLife;
                renderParticle(p, ctx, progress, delta);
            }
            ctx.restore();

            if (time > nextExplosionTime && !finaleSystem.isActive) {
                const interval = getCurrentExplosionInterval();
                
                let rocketCount = 1;
                if (climaxSystem.phase === 'climax') {
                    rocketCount = 1 + Math.floor(climaxIntensity / 2);
                }
                
                for (let i = 0; i < rocketCount; i++) {
                    setTimeout(() => {
                        if (isRunning && !finaleSystem.isActive) createRocket();
                    }, i * 50);
                }
                
                nextExplosionTime = time + interval;
            }
        }

        // ====================== KH·ªûI ƒê·ªòNG V·ªöI HI·ªÜU ·ª®NG N√öT ======================
        const btn = document.getElementById('startBtn');
        
        async function start() {
            btn.classList.add('clicked');
            
            setTimeout(async () => {
                try {
                    // Preload image tr∆∞·ªõc
                    await preloadFinaleImage();
                    
                    await initBackgroundMusic();
                    
                    if (!initAudioSystem()) {
                        alert("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Audio API. Vui l√≤ng d√πng Chrome/Firefox/Safari m·ªõi nh·∫•t.");
                        btn.classList.remove('clicked');
                        btn.style.visibility = 'visible';
                        return;
                    }
                    
                    playBackgroundMusic();
                    
                    initCanvas();
                    createParticlePool();

                    if (masterGain) {
                        masterGain.gain.setValueAtTime(0.001, audioCtx.currentTime);
                        masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 2.5);
                    }

                    setTimeout(() => {
                        playClimaxBass();
                    }, 500);

                    isRunning = true;
                    startTime = performance.now();
                    lastTime = startTime;
                    
                    nextExplosionTime = startTime + 300;
                    nextSoundTime = startTime + 800;

                    requestAnimationFrame(animate);
                    
                } catch (error) {
                    console.error("L·ªói kh·ªüi t·∫°o:", error);
                    alert("C√≥ l·ªói x·∫£y ra khi kh·ªüi t·∫°o. Vui l√≤ng th·ª≠ l·∫°i.");
                    btn.classList.remove('clicked');
                    btn.style.visibility = 'visible';
                }
            }, 800);
        }

        // ====================== EVENT LISTENERS ======================
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            start();
        }, { passive: false });
        
        btn.addEventListener('pointerdown', start);
        
        window.addEventListener('resize', () => {
            if (isRunning) initCanvas();
        });
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isRunning = false;
                pauseBackgroundMusic();
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                }
            } else if (startTime > 0) {
                isRunning = true;
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 0.5);
                }
                if (backgroundMusic && !isMusicPlaying) {
                    playBackgroundMusic();
                }
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
        
        window.addEventListener('beforeunload', () => {
            pauseBackgroundMusic();
        });
    </script>
</body>
</html>
