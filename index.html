<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ph√°o Hoa Cao Tr√†o - Peony, Special, Crossette</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: system-ui, sans-serif;
            color: #fff;
        }
        #canvas {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
        }
        
        #startBtn {
            position: relative;
            z-index: 10;
            padding: 20px 54px;
            font-size: 30px;
            font-weight: 700;
            color: #111;
            background: linear-gradient(135deg, #ffffff, #f3f3f3);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 28px;
            cursor: pointer;
            box-shadow: 
                0 10px 25px rgba(0, 0, 0, 0.08), 
                inset 0 1px 0 rgba(255, 255, 255, 0.9),
                0 0 0 4px rgba(255, 255, 255, 0.3),
                0 0 20px rgba(255, 255, 255, 0.5);
            transition: transform 0.35s cubic-bezier(.22,1,.36,1), 
                        box-shadow 0.35s ease, 
                        background 0.35s ease;
            letter-spacing: 0.5px;
            animation: 
                pulseGlow 2s ease-in-out infinite,
                bounceButton 1.5s ease-in-out infinite;
            overflow: hidden;
        }

        #startBtn::after {
            content: "";
            position: absolute;
            top: 0;
            left: -120%;
            width: 120%;
            height: 100%;
            background: linear-gradient(120deg, transparent, rgba(255,255,255,0.7), transparent);
            transition: left 0.6s ease;
        }

        #startBtn:hover::after {
            left: 120%;
        }

        #startBtn:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 
                0 18px 40px rgba(0, 0, 0, 0.12), 
                inset 0 1px 0 rgba(255, 255,255, 1),
                0 0 0 6px rgba(255, 255, 255, 0.5),
                0 0 30px rgba(255, 255, 255, 0.8);
            animation-play-state: paused;
        }

        #startBtn:active {
            transform: scale(0.95);
            box-shadow: 
                0 6px 15px rgba(0, 0, 0, 0.15),
                0 0 0 8px rgba(255, 255, 255, 0.8),
                0 0 40px rgba(255, 255, 255, 1);
            transition: transform 0.15s ease;
        }

        #startBtn.clicked {
            animation: fadeOutSmooth 0.9s cubic-bezier(.4,0,.2,1) forwards;
        }

        .btn-text {
            position: relative;
            z-index: 1;
            color: #111;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* COUNTDOWN STYLES */
        .countdown {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            display: none;
        }

        .number {
            position: absolute;
            font-size: 32vw;
            font-weight: 900;
            color: #ffffff;
            letter-spacing: -0.03em;
            opacity: 0;
            pointer-events: none;
            user-select: none;
            
            -webkit-text-stroke: 8px rgba(100,100,100,0.0);
            text-shadow: 
                0 0 15px rgba(255,255,255,0.4),
                0 0 35px rgba(200,200,255,0.3),
                4px 4px 12px rgba(80,80,80,0.5);
        }

        .n3 { transform: translate(-140vw, -30vh) scale(0.6); }
        .n2 { transform: translate(140vw,  40vh) scale(0.6); }
        .n1 { transform: translate(0,      120vh) scale(0.6); }

        .number.active {
            opacity: 1;
            transform: translate(0,0) scale(1);
            
            -webkit-text-stroke: 8px rgba(120,120,120,0.25);
            text-shadow: 
                0 0 40px rgba(255,255,255,0.8),
                0 0 80px rgba(220,220,255,0.6),
                0 0 120px rgba(180,180,255,0.4),
                8px 8px 20px rgba(100,100,100,0.7),
                -8px -8px 20px rgba(100,100,100,0.7);
                
            transition: 
        all 1s cubic-bezier(0.22, 0.9, 0.3, 1.2),  /* tƒÉng th·ªùi gian l√™n 1s */
        -webkit-text-stroke 1s ease-out,
        text-shadow 1s ease-out;
        }

        .number.fade-out {
            opacity: 0;
            transform: translate(0,0) scale(0.75);
            filter: blur(10px);
            -webkit-text-stroke: 8px rgba(120,120,120,0.0);
            text-shadow: 0 0 10px rgba(255,255,255,0.1);
            transition: all 0.5s ease-out;
        }

        .countdown-bg {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 75%);
            opacity: 0.8;
            pointer-events: none;
            z-index: 19;
        }

        /* Hi·ªáu ·ª©ng nh·∫•p nh√°y vi·ªÅn s√°ng */
        @keyframes pulseGlow {
            0%, 100% { 
                box-shadow: 
                    0 10px 25px rgba(0, 0, 0, 0.08), 
                    inset 0 1px 0 rgba(255, 255, 255, 0.9),
                    0 0 0 4px rgba(255, 255, 255, 0.3),
                    0 0 20px rgba(255, 255, 255, 0.5);
            }
            50% { 
                box-shadow: 
                    0 10px 25px rgba(0, 0, 0, 0.08), 
                    inset 0 1px 0 rgba(255, 255, 255, 0.9),
                    0 0 0 8px rgba(255, 255, 255, 0.6),
                    0 0 30px rgba(255, 255, 255, 0.8),
                    0 0 50px rgba(255, 255,255, 0.4);
            }
        }

        /* Hi·ªáu ·ª©ng nh·∫£y l√™n xu·ªëng */
        @keyframes bounceButton {
            0%, 100% { 
                transform: translateY(0); 
            }
            50% { 
                transform: translateY(-15px); 
            }
        }

        @keyframes fadeOutSmooth {
            0% { 
                opacity: 1; 
                transform: scale(1) translateY(0); 
                box-shadow: 
                    0 0 0 12px rgba(255, 255, 255, 0.9),
                    0 0 60px rgba(255, 255, 255, 1);
            }
            40% { 
                opacity: 0.8; 
                transform: scale(1.2) translateY(-25px); 
                box-shadow: 
                    0 0 0 20px rgba(255, 255, 255, 1),
                    0 0 100px rgba(255, 255, 255, 1);
            }
            100% { 
                opacity: 0; 
                transform: scale(0.8) translateY(80px); 
                visibility: hidden; 
                box-shadow: 
                    0 0 0 0 rgba(255, 255, 255, 0),
                    0 0 0 0 rgba(255, 255, 255, 0);
            }
        }
    </style>
</head>
<body>
    <button id="startBtn">
        <span class="btn-text">B·∫ÆT ƒê·∫¶U</span>
    </button>
    <canvas id="canvas"></canvas>
    
    <!-- COUNTDOWN ELEMENTS -->
    <div class="countdown-bg" style="display: none;"></div>
    <div class="countdown">
        <div class="number n3">3</div>
        <div class="number n2">2</div>
        <div class="number n1">1</div>
    </div>

    <script>
        // ====================== C·∫§U H√åNH √ÇM THANH ======================
        const SOUND_CONFIG = {
            masterVolume: 1.2,
            baseInterval: 1600,
            intervalVariation: 1000,
            fadeInTime: 0.2,
            fadeOutTime: 1.2,
            frequencyBlend: {
                min: 30,
                max: 80,
                glideTime: 0.6
            },
            layers: {
                sub: { weight: 0.9, freqRange: [30, 70] },
                deep: { weight: 0.6, freqRange: [20, 45] },
                rumble: { weight: 0.3, freqRange: [100, 300] }
            }
        };

        // ====================== C·∫§U H√åNH PH√ÅO HOA ======================
        const FIREWORK_CONFIG = {
            maxParticlesPerExplosion: 100,
            maxIntensity: 2.5,
            
            // ====================== C·∫§U H√åNH TH·ªúI GIAN T√çNH TO√ÅN ======================
            timeSystem: {
                // Th·ªùi gian s·ªëng trung b√¨nh c·ªßa particle (ms)
                particleLifetime: {
                    rocket: 1500,        // Ph√°o bay l√™n: 1.5s
                    explosion: 3000,     // Ph√°o n·ªï: 3s (GI·∫¢M ƒë·ªÉ chuy·ªÉn nhanh h∆°n)
                    special: 3800,       // Ph√°o ƒë·∫∑c bi·ªát: 3.8s (GI·∫¢M)
                    crossette: 3500      // Crossette: 3.5s (GI·∫¢M)
                },
                
                // Th·ªùi gian fade out cu·ªëi
                fadeOutDuration: 1500,   // 1.5s ƒë·ªÉ m·ªù ho√†n to√†n (GI·∫¢M)
                
                // Countdown duration
                countdownDuration: 2400  // 2.4s cho countdown 3-2-1
            },
            
            // ====================== C·∫§U H√åNH LOOP CAO TR√ÄO ======================
            climaxLoopSystem: {
                // TH·ªúI GIAN B√åNH TH∆Ø·ªúNG ƒê·∫¶U (t√≠nh to√°n d·ª±a tr√™n particle lifetime)
                normalDuration: 10000, // 10 gi√¢y b√¨nh th∆∞·ªùng ƒë·∫ßu
                
                // CAO TR√ÄO: 36 gi√¢y = 12s x 3 lo·∫°i (GI·∫¢M ƒë·ªÉ li√™n t·ª•c)
                climaxDuration: 36000, // 36 gi√¢y cao tr√†o
                climaxSegmentDuration: 12000, // 12 gi√¢y m·ªói segment
                
                // TH·ªúI GIAN B√åNH TH∆Ø·ªúNG CU·ªêI
                finalNormalDuration: 8000, // 8 gi√¢y b√¨nh th∆∞·ªùng cu·ªëi
                
                // T·ªîNG CHU K·ª≤: 10 + 36 + 8 = 54 gi√¢y
                totalCycleTime: 54000,
                
                // LO·∫†I PH√ÅO CAO TR√ÄO L·∫¶N ƒê·∫¶U (theo y√™u c·∫ßu)
                firstClimaxTypes: ['peony', 'special', 'crossette'],
                
                // T·∫•t c·∫£ lo·∫°i ph√°o c√≥ s·∫µn
                allFireworkTypes: [
                    'peony', 'special', 'crossette',
                    'chrysanthemum', 'ring', 'palm'
                ],
                
                // C·∫•u h√¨nh s·ªë l∆∞·ª£ng ph√°o
                normalRocketCount: {
                    min: 3,
                    max: 4
                },
                climaxRocketCount: {
                    min: 4,
                    max: 6
                },
                
                // Kho·∫£ng c√°ch gi·ªØa c√°c lo·∫°t ph√°o
                burstInterval: 100,
                
                // Kho·∫£ng c√°ch gi·ªØa c√°c l·∫ßn b·∫Øn ph√°o b√¨nh th∆∞·ªùng
                normalInterval: {
                    min: 1000,
                    max: 1600
                },
                // Kho·∫£ng c√°ch gi·ªØa c√°c l·∫ßn b·∫Øn ph√°o cao tr√†o
                climaxInterval: {
                    min: 250,
                    max: 450
                }
            },
            
            targetFPS: 60,
            maxActiveParticles: 1500,
            particleSizeMultiplier: 0.6,
            rocketSpeedMultiplier: 1.0,
            explosionSpeedMultiplier: 0.8,
            
            // C·∫§U H√åNH KHO·∫¢NG C√ÅCH
            distanceDistribution: {
                near: 0.2,
                far: 0.3,
                center: 0.5
            },
            
            distanceSettings: {
                near: {
                    minHeight: 0.25,
                    maxHeight: 0.45,
                    sizeMultiplier: 1.2,
                    speedMultiplier: 1.1,
                    brightnessBoost: 1.0,
                    glowIntensity: 1.0
                },
                far: {
                    minHeight: 0.7,
                    maxHeight: 0.95,
                    sizeMultiplier: 0.7,
                    speedMultiplier: 0.9,
                    brightnessBoost: 0.8,
                    glowIntensity: 0.7
                },
                center: {
                    minHeight: 0.5,
                    maxHeight: 0.7,
                    sizeMultiplier: 1.0,
                    speedMultiplier: 1.0,
                    brightnessBoost: 1.0,
                    glowIntensity: 0.9
                }
            },
            
            // SAO BƒÇNG CONFIG
            shootingStars: {
                count: 5,
                speed: 14,
                length: 80,
                colors: [
                    '#ffffff', '#a7d8ff', '#ffb3ba', '#ffdfba', 
                    '#ffffba', '#baffc9', '#bae1ff', '#f8b3ff'
                ],
                baseSize: 1.5,
                fadeDuration: 1200,
                
                mobile: {
                    speed: 12,
                    length: 60,
                    baseSize: 1.2
                }
            }
        };

        const MUSIC_FILE = 'phaobong.mp3';

        let canvas, ctx, audioCtx, masterGain, backgroundMusic;
        let particles = [];
        let shootingStars = [];
        let particlePoolSize = FIREWORK_CONFIG.maxParticlesPerExplosion * 25;
        let lastTime = 0, startTime = 0;
        let isRunning = false;
        let showShootingStars = true;
        let finalShootingStarsActive = false;
        let nextExplosionTime = 0;
        let nextSoundTime = 0;
        let soundSequence = 0;
        let activeSounds = new Set();
        let isMusicLoaded = false;
        let isMusicPlaying = false;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        // ====================== COUNTDOWN SYSTEM ======================
        let countdownSystem = {
            isActive: false,
            index: 0,
            numbers: null,
            countdownBg: null,
            countdownElement: null,
            onComplete: null
        };

        // ====================== H·ªÜ TH·ªêNG CAO TR√ÄO N√ÇNG CAO ======================
        let climaxSystem = {
            phase: 'normal',
            phaseStartTime: 0,
            climaxIntensity: 1.0,
            climaxMultiplier: 1.0,
            
            // H·ªá th·ªëng loop n√¢ng cao
            loopSystem: {
                currentCycleStart: 0,
                currentPhaseStart: 0,
                isInClimax: false,
                climaxSegmentIndex: -1,
                activeClimaxType: null,
                particlesCleared: true,
                segmentStartTime: 0,
                segmentParticlesFinished: false,
                isFirstCycle: true,
                currentClimaxTypes: [],
                allUsedTypes: new Set(),
                usedTypesHistory: [],
                isWaitingForCountdown: false,
                countdownStartTime: 0,
                shouldShowCountdown: true
            },
            
            soundIntensity: 1.0,
            lastBassTime: 0,
            bassInterval: 800
        };

        // ====================== INIT COUNTDOWN ======================
        function initCountdownSystem() {
            countdownSystem.countdownElement = document.querySelector('.countdown');
            countdownSystem.countdownBg = document.querySelector('.countdown-bg');
            countdownSystem.numbers = document.querySelectorAll('.number');
            
            // Reset t·∫•t c·∫£ s·ªë v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
            countdownSystem.numbers.forEach(num => {
                num.classList.remove('active', 'fade-out');
            });
        }

        // ====================== SHOW COUNTDOWN ======================
        function showCountdown(onComplete) {
            if (countdownSystem.isActive) return;
            
            countdownSystem.isActive = true;
            countdownSystem.index = 0;
            countdownSystem.onComplete = onComplete;
            
            // Hi·ªÉn th·ªã countdown
            countdownSystem.countdownElement.style.display = 'flex';
            countdownSystem.countdownBg.style.display = 'block';
            
            // Reset t·∫•t c·∫£ s·ªë
            countdownSystem.numbers.forEach(num => {
                num.classList.remove('active', 'fade-out');
            });
            
            // B·∫Øt ƒë·∫ßu countdown
            showNextNumber();
        }
function showNextNumber() {
    if (countdownSystem.index >= countdownSystem.numbers.length) {
        hideCountdown();
        if (countdownSystem.onComplete) {
            countdownSystem.onComplete();
        }
        return;
    }

    const currentNumber = countdownSystem.numbers[countdownSystem.index];

    // 1. Reset tr·∫°ng th√°i v·ªÅ ban ƒë·∫ßu (ƒë·ªÅ ph√≤ng)
    currentNumber.classList.remove('active', 'fade-out');

    // 2. Delay nh·ªè + d√πng requestAnimationFrame ƒë·ªÉ transition ho·∫°t ƒë·ªông ƒë√∫ng
    setTimeout(() => {
        requestAnimationFrame(() => {
            currentNumber.classList.add('active');
        });
    }, 40);  // 40ms l√† gi√° tr·ªã c√¢n b·∫±ng t·ªët gi·ªØa m∆∞·ª£t v√† nhanh

    // 3. Th·ªùi gian hi·ªÉn th·ªã s·ªë tr∆∞·ªõc khi fade out
    setTimeout(() => {
        currentNumber.classList.add('fade-out');

        // Chuy·ªÉn s·ªë ti·∫øp theo sau khi fade out g·∫ßn xong
        setTimeout(() => {
            countdownSystem.index++;
            showNextNumber();
        }, 500);
    }, 700 + 40);  // b√π th√™m ch√∫t th·ªùi gian delay ƒë·ªÉ nh·ªãp ƒë·ªÅu h∆°n
}

        function hideCountdown() {
            countdownSystem.isActive = false;
            countdownSystem.countdownElement.style.display = 'none';
            countdownSystem.countdownBg.style.display = 'none';
            
            // Reset t·∫•t c·∫£ s·ªë
            countdownSystem.numbers.forEach(num => {
                num.classList.remove('active', 'fade-out');
            });
        }

        // ====================== H·ªÜ TH·ªêNG SAO BƒÇNG ======================
        function createShootingStars(count = FIREWORK_CONFIG.shootingStars.count) {
            const starsConfig = FIREWORK_CONFIG.shootingStars;
            const mobileConfig = isMobile ? starsConfig.mobile : {};
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    if (!isRunning) return;
                    
                    const sizeCategory = Math.random();
                    let sizeMultiplier, speedMultiplier, glowIntensity, trailLength, sparkIntensity;
                    
                    if (sizeCategory < 0.5) {
                        sizeMultiplier = 0.3 + Math.random() * 0.3;
                        speedMultiplier = 1.3 + Math.random() * 0.4;
                        glowIntensity = 0.4;
                        trailLength = 8 + Math.floor(Math.random() * 6);
                        sparkIntensity = 0.6;
                    } else if (sizeCategory < 0.85) {
                        sizeMultiplier = 0.6 + Math.random() * 0.4;
                        speedMultiplier = 1.0 + Math.random() * 0.3;
                        glowIntensity = 0.6;
                        trailLength = 12 + Math.floor(Math.random() * 8);
                        sparkIntensity = 0.8;
                    } else {
                        sizeMultiplier = 1.0 + Math.random() * 0.5;
                        speedMultiplier = 0.7 + Math.random() * 0.3;
                        glowIntensity = 0.8;
                        trailLength = 18 + Math.floor(Math.random() * 10);
                        sparkIntensity = 1.0;
                    }
                    
                    if (isMobile) {
                        sizeMultiplier *= 0.8;
                        trailLength *= 0.7;
                    }
                    
                    const baseAngle = Math.PI / 4;
                    const angleVariation = Math.PI / 12;
                    const angle = baseAngle + (Math.random() - 0.5) * angleVariation * 2;
                    
                    const baseSpeed = (mobileConfig.speed || starsConfig.speed) * speedMultiplier;
                    
                    const star = {
                        x: -80 - Math.random() * 150,
                        y: Math.random() * window.innerHeight * 0.5,
                        vx: Math.cos(angle) * baseSpeed,
                        vy: Math.sin(angle) * baseSpeed,
                        life: 0,
                        maxLife: (800 + Math.random() * 600) / speedMultiplier,
                        color: starsConfig.colors[Math.floor(Math.random() * starsConfig.colors.length)],
                        baseSize: (mobileConfig.baseSize || starsConfig.baseSize) * sizeMultiplier,
                        size: (mobileConfig.baseSize || starsConfig.baseSize) * sizeMultiplier,
                        trail: [],
                        maxTrailLength: Math.floor(trailLength),
                        active: true,
                        brightness: 1.0,
                        glowIntensity: glowIntensity,
                        sizeMultiplier: sizeMultiplier,
                        sparkIntensity: sparkIntensity,
                        
                        twinklePhase: Math.random() * Math.PI * 2,
                        twinkleSpeed: 0.12 + Math.random() * 0.1,
                        twinkleAmplitude: 0.2 + Math.random() * 0.15,
                        
                        hueShift: (Math.random() - 0.5) * 40,
                        hueShiftSpeed: 0.02 + Math.random() * 0.03,
                        currentHue: 0,
                        
                        particleTimer: 0,
                        particleInterval: 80 / speedMultiplier,
                        
                        rotation: 0,
                        rotationSpeed: (0.08 + Math.random() * 0.1) * (sizeMultiplier > 1 ? 0.6 : 1.2),
                        
                        trailOpacity: 0.6 + Math.random() * 0.4,
                        
                        pulsePhase: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.05 + Math.random() * 0.05,
                        pulseAmplitude: 0.1 + Math.random() * 0.1,
                        
                        sparkleTimer: 0,
                        sparkleInterval: 40 + Math.random() * 30
                    };
                    
                    const colorMatch = star.color.match(/hsl\((\d+)/);
                    star.currentHue = colorMatch ? parseInt(colorMatch[1]) : Math.random() * 360;
                    
                    shootingStars.push(star);
                    
                }, i * (180 + Math.random() * 120));
            }
        }

        function createSparks(x, y, baseColor, intensity = 1.0) {
            const sparkCount = Math.floor((1 + Math.random() * 3) * intensity);
            
            for (let i = 0; i < sparkCount; i++) {
                const spark = getParticle();
                if (!spark) continue;
                
                const hueShift = (Math.random() - 0.5) * 60;
                const brightness = 70 + Math.random() * 25;
                const sparkColor = `hsl(${(parseInt(baseColor.match(/\d+/)?.[0] || 200) + hueShift) % 360}, 100%, ${brightness}%)`;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (0.5 + Math.random() * 2) * intensity;
                
                spark.x = x + (Math.random() - 0.5) * 8;
                spark.y = y + (Math.random() - 0.5) * 8;
                spark.vx = Math.cos(angle) * speed;
                spark.vy = Math.sin(angle) * speed;
                spark.life = 0;
                spark.maxLife = 15 + Math.random() * 25;
                spark.color = sparkColor;
                spark.size = (0.4 + Math.random() * 0.6) * intensity;
                spark.active = true;
                spark.fade = 0.9;
                spark.drag = 0.96;
                spark.sparkle = true;
                spark.glitter = Math.random() > 0.7;
                
                spark.twinklePhase = Math.random() * Math.PI * 2;
                spark.twinkleSpeed = 0.15 + Math.random() * 0.1;
            }
        }

        function updateShootingStars(delta) {
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const star = shootingStars[i];
                
                if (!star.active) {
                    shootingStars.splice(i, 1);
                    continue;
                }
                
                star.x += star.vx * delta;
                star.y += star.vy * delta;
                star.life += delta * 16.67;
                
                star.rotation += star.rotationSpeed * delta;
                
                star.twinklePhase += star.twinkleSpeed * delta;
                const twinkle = 0.8 + Math.sin(star.twinklePhase) * star.twinkleAmplitude;
                
                star.currentHue = (star.currentHue + star.hueShiftSpeed * delta * 10) % 360;
                
                star.pulsePhase += star.pulseSpeed * delta;
                const pulse = 1 + Math.sin(star.pulsePhase) * star.pulseAmplitude;
                
                if (star.sizeMultiplier > 0.8) {
                    star.size = star.baseSize * twinkle * pulse;
                }
                
                star.trail.push({ 
                    x: star.x, 
                    y: star.y,
                    size: star.size * twinkle,
                    opacity: star.trailOpacity * star.brightness,
                    hue: star.currentHue
                });
                
                if (star.trail.length > star.maxTrailLength) {
                    star.trail.shift();
                }
                
                star.sparkleTimer += delta * 16.67;
                if (star.sparkleTimer >= star.sparkleInterval && star.brightness > 0.5) {
                    star.sparkleTimer = 0;
                    if (Math.random() > 0.3) {
                        createSparks(star.x, star.y, `hsl(${star.currentHue}, 100%, 80%)`, star.sparkleIntensity * 0.5);
                    }
                }
                
                star.particleTimer += delta * 16.67;
                if (star.particleTimer >= star.particleInterval && star.brightness > 0.7) {
                    star.particleTimer = 0;
                    if (Math.random() > 0.5) {
                        createSparks(star.x, star.y, `hsl(${star.currentHue}, 100%, 85%)`, star.sparkIntensity * 0.4);
                    }
                }
                
                const fadeStart = 0.65;
                if (star.life > star.maxLife * fadeStart) {
                    const fadeProgress = (star.life - star.maxLife * fadeStart) / (star.maxLife * (1 - fadeStart));
                    star.brightness = Math.pow(1 - fadeProgress, 3);
                    star.trailOpacity = 0.6 * star.brightness;
                }
                
                if (star.life >= star.maxLife || 
                    star.x > window.innerWidth + 100 || 
                    star.y > window.innerHeight + 100) {
                    if (star.sizeMultiplier > 0.8 && star.brightness > 0.3) {
                        createSparks(star.x, star.y, `hsl(${star.currentHue}, 100%, 90%)`, star.sparkIntensity * 0.8);
                    }
                    star.active = false;
                }
            }
        }

        function renderShootingStars() {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            for (const star of shootingStars) {
                if (!star.active || star.trail.length < 2) continue;
                
                const alpha = star.brightness;
                const currentColor = `hsl(${star.currentHue}, 100%, 85%)`;
                
                if (star.glowIntensity > 0.5 && alpha > 0.3) {
                    ctx.shadowBlur = 8 * star.glowIntensity * alpha;
                    ctx.shadowColor = currentColor.replace(')', `, ${alpha * 0.5})`);
                    
                    ctx.beginPath();
                    ctx.moveTo(star.trail[0].x, star.trail[0].y);
                    for (let i = 1; i < star.trail.length; i++) {
                        ctx.lineTo(star.trail[i].x, star.trail[i].y);
                    }
                    ctx.strokeStyle = currentColor.replace(')', `, ${alpha * 0.3})`);
                    ctx.lineWidth = star.size * 1.5;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                }
                
                for (let i = 0; i < star.trail.length - 1; i++) {
                    const point1 = star.trail[i];
                    const point2 = star.trail[i + 1];
                    const progress = i / star.trail.length;
                    
                    const segmentAlpha = alpha * point1.opacity * (1 - progress * 0.8);
                    if (segmentAlpha < 0.05) continue;
                    
                    const gradient = ctx.createLinearGradient(
                        point1.x, point1.y,
                        point2.x, point2.y
                    );
                    
                    const color1 = `hsl(${point1.hue}, 100%, 85%)`.replace(')', `, ${segmentAlpha * 0.9})`);
                    const color2 = `hsl(${point2.hue}, 100%, 85%)`.replace(')', `, ${segmentAlpha * 0.6})`);
                    
                    gradient.addColorStop(0, color1);
                    gradient.addColorStop(1, color2);
                    
                    ctx.beginPath();
                    ctx.moveTo(point1.x, point1.y);
                    ctx.lineTo(point2.x, point2.y);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = point1.size * (1.5 - progress * 0.7);
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
                
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * 1.2, 0, Math.PI * 2);
                const coreGradient = ctx.createRadialGradient(
                    star.x, star.y, 0,
                    star.x, star.y, star.size * 1.2
                );
                coreGradient.addColorStop(0, '#FFFFFF');
                coreGradient.addColorStop(0.7, currentColor.replace(')', `, ${alpha * 0.9})`));
                coreGradient.addColorStop(1, currentColor.replace(')', `, ${alpha * 0.3})`));
                ctx.fillStyle = coreGradient;
                ctx.fill();
                
                if (star.sizeMultiplier > 0.9 && alpha > 0.5) {
                    ctx.save();
                    ctx.translate(star.x, star.y);
                    ctx.rotate(star.rotation);
                    
                    const spikes = Math.random() > 0.5 ? 4 : 5;
                    const outerRadius = star.size * 1.8;
                    const innerRadius = star.size * 0.8;
                    
                    ctx.beginPath();
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (Math.PI * i) / spikes;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    
                    const starGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerRadius);
                    starGradient.addColorStop(0, '#FFFFFF');
                    starGradient.addColorStop(0.3, currentColor.replace(')', `, ${alpha * 0.8})`));
                    starGradient.addColorStop(1, currentColor.replace(')', `, ${alpha * 0.2})`));
                    
                    ctx.fillStyle = starGradient;
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fill();
                    ctx.restore();
                }
                
                if (star.glowIntensity > 0.4 && alpha > 0.2) {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size * 2.5 * star.glowIntensity, 0, Math.PI * 2);
                    const glowGradient = ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, star.size * 2.5 * star.glowIntensity
                    );
                    glowGradient.addColorStop(0, currentColor.replace(')', `, ${0.4 * alpha * star.glowIntensity})`));
                    glowGradient.addColorStop(0.6, currentColor.replace(')', `, ${0.2 * alpha * star.glowIntensity})`));
                    glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                }
                
                if (star.brightness > 0.6 && Math.sin(star.twinklePhase) > 0.8) {
                    const sparkleSize = star.size * 0.8;
                    const angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                    
                    for (const angle of angles) {
                        const distance = star.size * 2;
                        const sparkleX = star.x + Math.cos(star.rotation + angle) * distance;
                        const sparkleY = star.y + Math.sin(star.rotation + angle) * distance;
                        
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.globalAlpha = alpha * 0.4 * star.brightness;
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                }
            }
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }

        // ====================== H√ÄM ƒê·∫æM V√Ä X√ìA PARTICLE ======================
        function countActiveParticles() {
            let count = 0;
            for (let p of particles) {
                if (p.active) count++;
            }
            return count;
        }

        function clearAllParticles() {
            let clearedCount = 0;
            for (let p of particles) {
                if (p.active) {
                    p.active = false;
                    clearedCount++;
                }
            }
            return clearedCount;
        }

        function areAllParticlesFaded() {
            for (let p of particles) {
                if (p.active) {
                    if (p.life < p.maxLife * 0.85) {
                        return false;
                    }
                }
            }
            return true;
        }

        // ====================== H·ªÜ TH·ªêNG LOOP N√ÇNG CAO ======================
        function updateClimaxLoopSystem(currentTime) {
            if (!startTime) return 1.0;
            
            const loopConfig = FIREWORK_CONFIG.climaxLoopSystem;
            const totalCycleTime = loopConfig.totalCycleTime;
            
            // Kh·ªüi t·∫°o l·∫ßn ƒë·∫ßu
            if (climaxSystem.loopSystem.currentCycleStart === 0) {
                climaxSystem.loopSystem.currentCycleStart = currentTime;
                climaxSystem.loopSystem.currentPhaseStart = currentTime;
                climaxSystem.loopSystem.isInClimax = false;
                climaxSystem.loopSystem.activeClimaxType = null;
                climaxSystem.loopSystem.particlesCleared = true;
                climaxSystem.loopSystem.isFirstCycle = true;
                climaxSystem.loopSystem.currentClimaxTypes = [...loopConfig.firstClimaxTypes];
                console.log("üöÄ B·∫Øt ƒë·∫ßu chu k·ª≥ ƒë·∫ßu ti√™n");
                console.log("üìã Lo·∫°i ph√°o cao tr√†o l·∫ßn ƒë·∫ßu: Peony ‚Üí Special ‚Üí Crossette");
            }
            
            // T√≠nh th·ªùi gian trong chu k·ª≥ hi·ªán t·∫°i
            const timeInCycle = (currentTime - climaxSystem.loopSystem.currentCycleStart) % totalCycleTime;
            
            // PHASE 1: 10 gi√¢y ƒë·∫ßu b√¨nh th∆∞·ªùng
            if (timeInCycle < loopConfig.normalDuration) {
                if (climaxSystem.loopSystem.isInClimax) {
                    // Chuy·ªÉn t·ª´ cao tr√†o sang b√¨nh th∆∞·ªùng
                    climaxSystem.loopSystem.isInClimax = false;
                    climaxSystem.loopSystem.activeClimaxType = null;
                    climaxSystem.loopSystem.climaxSegmentIndex = -1;
                    climaxSystem.loopSystem.currentPhaseStart = currentTime;
                    console.log("‚è∏Ô∏è K·∫øt th√∫c cao tr√†o");
                }
                
                // Ki·ªÉm tra n·∫øu s·∫Øp h·∫øt phase b√¨nh th∆∞·ªùng v√† c·∫ßn chu·∫©n b·ªã countdown
                const timeLeftInNormal = loopConfig.normalDuration - timeInCycle;
                const countdownTime = FIREWORK_CONFIG.timeSystem.countdownDuration;
                
                if (timeLeftInNormal <= countdownTime && 
                    !climaxSystem.loopSystem.isWaitingForCountdown &&
                    climaxSystem.loopSystem.shouldShowCountdown) {
                    
                    // B·∫Øt ƒë·∫ßu countdown
                    climaxSystem.loopSystem.isWaitingForCountdown = true;
                    climaxSystem.loopSystem.countdownStartTime = currentTime;
                    
                    // Show countdown
                    showCountdown(() => {
                        console.log("üéÜ Countdown ho√†n t·∫•t, b·∫Øt ƒë·∫ßu cao tr√†o!");
                    });
                }
                
                climaxSystem.phase = 'normal';
                climaxSystem.climaxIntensity = 1.0;
                
                // Chu·∫©n b·ªã lo·∫°i ph√°o cho cao tr√†o ti·∫øp theo
                if (timeInCycle > loopConfig.normalDuration - 3000 && 
                    !climaxSystem.loopSystem.isFirstCycle &&
                    climaxSystem.loopSystem.currentClimaxTypes.length === 0) {
                    
                    climaxSystem.loopSystem.currentClimaxTypes = selectRandomClimaxTypes();
                }
                
            } 
            // PHASE 2: 36 gi√¢y cao tr√†o
            else if (timeInCycle < loopConfig.normalDuration + loopConfig.climaxDuration) {
                if (!climaxSystem.loopSystem.isInClimax) {
                    // B·∫Øt ƒë·∫ßu cao tr√†o
                    climaxSystem.loopSystem.isInClimax = true;
                    climaxSystem.loopSystem.currentPhaseStart = currentTime;
                    climaxSystem.loopSystem.climaxSegmentIndex = 0;
                    climaxSystem.loopSystem.segmentStartTime = currentTime;
                    climaxSystem.loopSystem.segmentParticlesFinished = false;
                    climaxSystem.loopSystem.isWaitingForCountdown = false;
                    
                    // Clear particle c√≤n l·∫°i
                    clearAllParticles();
                    climaxSystem.loopSystem.particlesCleared = true;
                    
                    console.log("üéÜ B·∫ÆT ƒê·∫¶U CAO TR√ÄO 36 GI√ÇY");
                    
                    if (climaxSystem.loopSystem.isFirstCycle) {
                        climaxSystem.loopSystem.currentClimaxTypes = [...loopConfig.firstClimaxTypes];
                        loopConfig.firstClimaxTypes.forEach(type => 
                            climaxSystem.loopSystem.allUsedTypes.add(type));
                        climaxSystem.loopSystem.usedTypesHistory.push([...loopConfig.firstClimaxTypes]);
                    }
                    
                    climaxSystem.loopSystem.activeClimaxType = 
                        climaxSystem.loopSystem.currentClimaxTypes[0];
                    
                    console.log(`üéá Segment 1/3: ${climaxSystem.loopSystem.activeClimaxType}`);
                }
                
                climaxSystem.phase = 'climax';
                
                // T√≠nh th·ªùi gian trong cao tr√†o
                const timeInClimax = currentTime - climaxSystem.loopSystem.currentPhaseStart;
                
                // X√°c ƒë·ªãnh segment hi·ªán t·∫°i (0, 1, 2)
                const segmentIndex = Math.floor(timeInClimax / loopConfig.climaxSegmentDuration);
                
                // Ki·ªÉm tra chuy·ªÉn segment
                if (segmentIndex !== climaxSystem.loopSystem.climaxSegmentIndex) {
                    // Chuy·ªÉn segment ngay l·∫≠p t·ª©c
                    climaxSystem.loopSystem.climaxSegmentIndex = segmentIndex;
                    climaxSystem.loopSystem.segmentStartTime = currentTime;
                    climaxSystem.loopSystem.segmentParticlesFinished = false;
                    
                    // Clear particle c√≤n l·∫°i
                    clearAllParticles();
                    climaxSystem.loopSystem.particlesCleared = true;
                    
                    if (segmentIndex < climaxSystem.loopSystem.currentClimaxTypes.length) {
                        climaxSystem.loopSystem.activeClimaxType = 
                            climaxSystem.loopSystem.currentClimaxTypes[segmentIndex];
                        console.log(`üéá Segment ${segmentIndex + 1}/3: ${climaxSystem.loopSystem.activeClimaxType}`);
                    }
                } else {
                    // ƒêang trong segment hi·ªán t·∫°i
                    const timeInSegment = currentTime - climaxSystem.loopSystem.segmentStartTime;
                    const segmentProgress = timeInSegment / loopConfig.climaxSegmentDuration;
                    
                    // T√≠nh to√°n khi n√†o ng·ª´ng t·∫°o ph√°o m·ªõi (tr∆∞·ªõc khi k·∫øt th√∫c segment)
                    if (segmentProgress > 0.8 && !climaxSystem.loopSystem.segmentParticlesFinished) {
                        // Ng·ª´ng t·∫°o ph√°o m·ªõi, ƒë·ªÉ particle hi·ªán t·∫°i m·ªù d·∫ßn
                        climaxSystem.loopSystem.segmentParticlesFinished = true;
                    }
                    
                    // T√≠nh c∆∞·ªùng ƒë·ªô trong segment
                    if (segmentProgress < 0.3) {
                        climaxSystem.climaxIntensity = 1.0 + segmentProgress * 3.0;
                    } else if (segmentProgress < 0.7) {
                        climaxSystem.climaxIntensity = 2.0 + (segmentProgress - 0.3) * 0.5;
                    } else {
                        climaxSystem.climaxIntensity = 2.2 - (segmentProgress - 0.7) * 2.0;
                    }
                }
                
            } 
            // PHASE 3: 8 gi√¢y cu·ªëi b√¨nh th∆∞·ªùng
            else {
                if (climaxSystem.loopSystem.isInClimax) {
                    // K·∫øt th√∫c cao tr√†o
                    climaxSystem.loopSystem.isInClimax = false;
                    climaxSystem.loopSystem.activeClimaxType = null;
                    climaxSystem.loopSystem.climaxSegmentIndex = -1;
                    climaxSystem.loopSystem.currentPhaseStart = currentTime;
                    climaxSystem.loopSystem.isFirstCycle = false;
                    climaxSystem.loopSystem.shouldShowCountdown = true;
                    
                    // Reset lo·∫°i ph√°o cho l·∫ßn sau
                    climaxSystem.loopSystem.currentClimaxTypes = [];
                    
                    console.log("‚úÖ K·∫øt th√∫c cao tr√†o");
                }
                
                climaxSystem.phase = 'normal';
                climaxSystem.climaxIntensity = 1.0;
            }
            
            climaxSystem.climaxMultiplier = 1.0 / Math.max(climaxSystem.climaxIntensity, 0.5);
            return climaxSystem.climaxIntensity;
        }

        // ====================== H√ÄM CH·ªåN LO·∫†I PH√ÅO NG·∫™U NHI√äN ======================
        function selectRandomClimaxTypes() {
            const loopConfig = FIREWORK_CONFIG.climaxLoopSystem;
            const allTypes = [...loopConfig.allFireworkTypes];
            const usedTypes = climaxSystem.loopSystem.allUsedTypes;
            
            const availableTypes = allTypes.filter(type => !usedTypes.has(type));
            
            if (availableTypes.length < 3) {
                climaxSystem.loopSystem.allUsedTypes.clear();
                climaxSystem.loopSystem.usedTypesHistory = [];
                return getRandomTypes(loopConfig.allFireworkTypes, 3);
            }
            
            const selectedTypes = getRandomTypes(availableTypes, 3);
            
            selectedTypes.forEach(type => climaxSystem.loopSystem.allUsedTypes.add(type));
            climaxSystem.loopSystem.usedTypesHistory.push([...selectedTypes]);
            
            console.log("üé≤ Lo·∫°i ph√°o ƒë∆∞·ª£c ch·ªçn ng·∫´u nhi√™n:", selectedTypes);
            return selectedTypes;
        }

        function getRandomTypes(typesArray, count) {
            const shuffled = [...typesArray].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        function getCurrentExplosionInterval() {
            const loopConfig = FIREWORK_CONFIG.climaxLoopSystem;
            
            if (climaxSystem.loopSystem.isInClimax && 
                !climaxSystem.loopSystem.segmentParticlesFinished) {
                const min = loopConfig.climaxInterval.min * climaxSystem.climaxMultiplier;
                const max = loopConfig.climaxInterval.max * climaxSystem.climaxMultiplier;
                return Math.random() * (max - min) + min;
            } else {
                const min = loopConfig.normalInterval.min * climaxSystem.climaxMultiplier;
                const max = loopConfig.normalInterval.max * climaxSystem.climaxMultiplier;
                return Math.random() * (max - min) + min;
            }
        }

        function getRocketCount() {
            const loopConfig = FIREWORK_CONFIG.climaxLoopSystem;
            
            if (climaxSystem.loopSystem.isInClimax && 
                !climaxSystem.loopSystem.segmentParticlesFinished) {
                const min = loopConfig.climaxRocketCount.min;
                const max = loopConfig.climaxRocketCount.max;
                return min + Math.floor(Math.random() * (max - min + 1));
            } else {
                const min = loopConfig.normalRocketCount.min;
                const max = loopConfig.normalRocketCount.max;
                return min + Math.floor(Math.random() * (max - min + 1));
            }
        }

        function shouldCreateRocket() {
            if (countdownSystem.isActive) return false;
            
            if (climaxSystem.loopSystem.isInClimax && 
                climaxSystem.loopSystem.segmentParticlesFinished) {
                return false;
            }
            
            return true;
        }

        function getExplosionTypeForPhase() {
            if (climaxSystem.loopSystem.isInClimax && 
                climaxSystem.loopSystem.activeClimaxType &&
                !climaxSystem.loopSystem.segmentParticlesFinished) {
                return climaxSystem.loopSystem.activeClimaxType;
            }
            
            const availableTypes = ['peony', 'chrysanthemum', 'ring', 'palm', 'crossette'];
            return availableTypes[Math.floor(Math.random() * availableTypes.length)];
        }

        // ====================== H·ªÜ TH·ªêNG NH·∫†C N·ªÄN ======================
        function initBackgroundMusic() {
            return new Promise((resolve, reject) => {
                try {
                    backgroundMusic = new Audio();
                    backgroundMusic.src = MUSIC_FILE;
                    backgroundMusic.loop = true;
                    backgroundMusic.volume = 0.6;
                    backgroundMusic.preload = 'auto';
                    
                    backgroundMusic.addEventListener('loadeddata', () => {
                        isMusicLoaded = true;
                        resolve(true);
                    });
                    
                    backgroundMusic.addEventListener('error', (e) => {
                        console.error("L·ªói t·∫£i nh·∫°c:", e);
                        resolve(false);
                    });
                    
                    backgroundMusic.load();
                    
                } catch (e) {
                    console.error("L·ªói kh·ªüi t·∫°o nh·∫°c:", e);
                    resolve(false);
                }
            });
        }

        function playBackgroundMusic() {
            if (!backgroundMusic || !isMusicLoaded) {
                return false;
            }
            
            try {
                backgroundMusic.volume = 0;
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        fadeMusicVolume(0, 0.6, 1.5);
                    }).catch(error => {
                        console.error("L·ªói ph√°t nh·∫°c:", error);
                    });
                }
                
                return true;
            } catch (e) {
                console.error("L·ªói khi ph√°t nh·∫°c:", e);
                return false;
            }
        }

        function fadeMusicVolume(from, to, duration) {
            if (!backgroundMusic) return;
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            function updateVolume() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / (duration * 1000), 1);
                const currentVolume = from + (to - from) * progress;
                
                backgroundMusic.volume = Math.max(0, Math.min(1, currentVolume));
                
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }

        // ====================== H·ªÜ TH·ªêNG √ÇM THANH ======================
        function initAudioSystem() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioCtx.createGain();
                masterGain.gain.value = SOUND_CONFIG.masterVolume;
                
                masterGain.connect(audioCtx.destination);
                
                return true;
            } catch (e) {
                console.log("Audio kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£, ti·∫øp t·ª•c kh√¥ng √¢m thanh");
                return false;
            }
        }

        function createSimpleBassSound(frequency, duration = 1.0, volume = 1.0) {
            if (!audioCtx || activeSounds.size > 4) return null;
            
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = frequency;
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            const soundId = Symbol();
            activeSounds.add(soundId);
            
            setTimeout(() => {
                activeSounds.delete(soundId);
            }, duration * 1000);
            
            return soundId;
        }

        function playBassSound() {
            if (!audioCtx || activeSounds.size > 3) return;
            
            const currentTime = performance.now();
            
            if (climaxSystem.loopSystem.isInClimax && 
                currentTime - climaxSystem.lastBassTime > climaxSystem.bassInterval) {
                climaxSystem.lastBassTime = currentTime;
                
                if (Math.random() > 0.6) {
                    const baseFreq = 40 + Math.random() * 20 * climaxSystem.soundIntensity;
                    createSimpleBassSound(
                        baseFreq,
                        0.8 + Math.random() * 0.4,
                        SOUND_CONFIG.layers.sub.weight * climaxSystem.soundIntensity * 0.8
                    );
                }
            } else if (currentTime > nextSoundTime) {
                soundSequence = (soundSequence + 1) % 3;
                const baseFreq = 45 + Math.random() * 15;
                
                createSimpleBassSound(
                    baseFreq,
                    1.0 + Math.random() * 0.5,
                    SOUND_CONFIG.layers.sub.weight * 0.7
                );
                
                nextSoundTime = currentTime + SOUND_CONFIG.baseInterval + (Math.random() - 0.5) * SOUND_CONFIG.intervalVariation;
            }
        }

        // ====================== H·ªÜ TH·ªêNG PH√ÅO HOA ======================
        function createParticlePool() {
            particles = [];
            
            for (let i = 0; i < particlePoolSize; i++) {
                particles.push({
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 0,
                    color: '#fff',
                    size: 1.0,
                    active: false,
                    isNear: false,
                    isCenter: false,
                    isRocket: false,
                    isSpecial: false,
                    
                    trail: false,
                    sparkle: false,
                    glitter: false,
                    fade: 1.0,
                    gravity: 0.08,
                    drag: 0.97,
                    
                    glowSize: 0,
                    trailLength: 0,
                    climaxType: null,
                    explosionType: null
                });
            }
        }

        function getParticle() {
            for (let p of particles) {
                if (!p.active) return p;
            }
            
            let oldestParticle = null;
            let oldestLife = 0;
            for (let p of particles) {
                if (p.active) {
                    const lifeRatio = p.life / p.maxLife;
                    if (lifeRatio > oldestLife) {
                        oldestLife = lifeRatio;
                        oldestParticle = p;
                    }
                }
            }
            
            if (oldestParticle && oldestLife > 0.7) {
                oldestParticle.active = false;
                return oldestParticle;
            }
            
            return null;
        }

        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // ====================== T·∫†O PH√ÅO HOA ======================
        function createRocket() {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.9) return;
            
            if (!shouldCreateRocket()) return;

            const rand = Math.random();
            let distanceType;
            
            if (rand < FIREWORK_CONFIG.distanceDistribution.near) {
                distanceType = 'near';
            } else if (rand < FIREWORK_CONFIG.distanceDistribution.near + FIREWORK_CONFIG.distanceDistribution.far) {
                distanceType = 'far';
            } else {
                distanceType = 'center';
            }
            
            const settings = FIREWORK_CONFIG.distanceSettings[distanceType];
            
            const x = Math.random() * window.innerWidth;
            const yStart = window.innerHeight;
            const hue = Math.random() * 360;

            const p = getParticle();
            if (p) {
                p.x = x;
                p.y = yStart;
                p.vx = (Math.random() - 0.5) * 1.2 * climaxSystem.climaxIntensity;
                p.vy = -(10 + Math.random() * 5) * FIREWORK_CONFIG.rocketSpeedMultiplier * settings.speedMultiplier * climaxSystem.climaxIntensity;
                p.life = 0;
                
                const explosionType = getExplosionTypeForPhase();
                if (explosionType === 'special') {
                    p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.special / 16.67;
                } else if (explosionType === 'crossette') {
                    p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.crossette / 16.67;
                } else {
                    p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.rocket / 16.67;
                }
                
                p.color = `hsl(${hue}, 100%, ${distanceType === 'near' ? 80 : (distanceType === 'center' ? 75 : 70)}%)`;
                p.size = (1.2 + Math.random() * 0.6) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * climaxSystem.climaxIntensity;
                p.active = true;
                p.isRocket = true;
                p.isNear = distanceType === 'near';
                p.isCenter = distanceType === 'center';
                p.glowSize = p.size * 2.0 * climaxSystem.climaxIntensity;
                p.explosionType = explosionType;
            }

            setTimeout(() => {
                if (!isRunning) return;
                if (!shouldCreateRocket()) return;
                
                const minHeight = settings.minHeight * window.innerHeight;
                const maxHeight = settings.maxHeight * window.innerHeight;
                const yExplode = minHeight + Math.random() * (maxHeight - minHeight);
                
                const explosionType = getExplosionTypeForPhase();
                createSimpleExplosion(x, yExplode, hue, distanceType, explosionType);
                
                if (climaxSystem.loopSystem.isInClimax && 
                    Math.random() > 0.7) {
                    playBassSound();
                }
            }, (distanceType === 'near' ? 500 : 700) + Math.random() * 400 / climaxSystem.climaxIntensity);
        }

        // ====================== C√ÅC KI·ªÇU N·ªî PH√ÅO HOA ======================
        function createSimpleExplosion(x, y, baseHue, distanceType, type = 'peony') {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.85) return;

            const settings = FIREWORK_CONFIG.distanceSettings[distanceType];
            const intensityMultiplier = climaxSystem.climaxIntensity;
            
            switch(type) {
                case 'chrysanthemum':
                    createChrysanthemumExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier);
                    break;
                case 'peony':
                    createPeonyExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier);
                    break;
                case 'palm':
                    createPalmExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier);
                    break;
                case 'ring':
                    createRingExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier);
                    break;
                case 'crossette':
                    createCrossetteExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier);
                    break;
                case 'special':
                    createSpecialExplosion(x, y, baseHue, distanceType, intensityMultiplier);
                    break;
                default:
                    createPeonyExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier);
            }
        }

        function createChrysanthemumExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier) {
            const rays = Math.floor((20 + Math.random() * 15) * intensityMultiplier);
            const particlesPerRay = Math.floor((5 + Math.random() * 4) * intensityMultiplier);
            
            for (let i = 0; i < rays; i++) {
                const angle = (Math.PI * 2 * i) / rays;
                
                for (let j = 0; j < particlesPerRay; j++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const speed = (3 + j * 0.5 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * intensityMultiplier;
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.explosion / 16.67;
                    
                    const hueShift = (Math.random() - 0.5) * 20;
                    const brightness = distanceType === 'near' ? 70 : (distanceType === 'center' ? 65 : 60);
                    p.color = `hsl(${baseHue + hueShift}, 100%, ${brightness + Math.random() * 20}%)`;
                    
                    p.size = (0.7 + Math.random() * 0.5) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * intensityMultiplier;
                    p.active = true;
                    p.isNear = distanceType === 'near';
                    p.isCenter = distanceType === 'center';
                    p.trail = true;
                    p.sparkle = j % 2 === 0;
                    p.gravity = 0.09;
                    p.drag = 0.985;
                    p.glowSize = p.size * 1.8 * intensityMultiplier;
                    p.explosionType = 'chrysanthemum';
                }
            }
        }

        function createPeonyExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier) {
            const numParticles = Math.floor(((distanceType === 'near' ? 90 : (distanceType === 'center' ? 85 : 75)) + Math.random() * 60) * intensityMultiplier);
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (2.5 + Math.random() * 3.5) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * intensityMultiplier;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.explosion / 16.67;
                const brightness = distanceType === 'near' ? 75 : (distanceType === 'center' ? 70 : 65);
                p.color = `hsl(${baseHue}, 100%, ${brightness + Math.random() * 20}%)`;
                p.size = (0.9 + Math.random() * 0.7) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * intensityMultiplier;
                p.active = true;
                p.isNear = distanceType === 'near';
                p.isCenter = distanceType === 'center';
                p.trail = Math.random() > 0.4;
                p.glitter = Math.random() > 0.6;
                p.gravity = 0.1;
                p.drag = 0.98;
                p.glowSize = p.size * 2.0 * intensityMultiplier;
                p.explosionType = 'peony';
            }
        }

        function createPalmExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier) {
            const branches = Math.floor((8 + Math.random() * 6) * intensityMultiplier);
            
            for (let i = 0; i < branches; i++) {
                const angle = (Math.PI * 2 * i) / branches + (Math.random() - 0.5) * 0.3;
                const particlesPerBranch = Math.floor((12 + Math.random() * 8) * intensityMultiplier);
                
                for (let j = 0; j < particlesPerBranch; j++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const speed = (4 + j * 0.3 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * intensityMultiplier;
                    const angleVariation = (Math.random() - 0.5) * 0.2;
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle + angleVariation) * speed;
                    p.vy = Math.sin(angle + angleVariation) * speed - 2;
                    p.life = 0;
                    p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.explosion / 16.67;
                    
                    const palmHue = 45 + Math.random() * 30;
                    p.color = `hsl(${palmHue}, 100%, ${70 + Math.random() * 20}%)`;
                    
                    p.size = (0.6 + Math.random() * 0.5) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * intensityMultiplier;
                    p.active = true;
                    p.isNear = distanceType === 'near';
                    p.isCenter = distanceType === 'center';
                    p.trail = true;
                    p.gravity = 0.15;
                    p.drag = 0.96;
                    p.glowSize = p.size * 2.2 * intensityMultiplier;
                    p.explosionType = 'palm';
                }
            }
        }

        function createRingExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier) {
            const rings = Math.floor(2 + Math.random() * 2);
            
            for (let ring = 0; ring < rings; ring++) {
                const numParticles = Math.floor((40 + Math.random() * 30) * intensityMultiplier);
                const ringSpeed = 3 + ring * 1.5;
                const ringHue = (baseHue + ring * 60) % 360;
                
                setTimeout(() => {
                    for (let i = 0; i < numParticles; i++) {
                        const p = getParticle();
                        if (!p) continue;
                        
                        const angle = (Math.PI * 2 * i) / numParticles;
                        const speed = ringSpeed * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * intensityMultiplier;
                        
                        p.x = x;
                        p.y = y;
                        p.vx = Math.cos(angle) * speed;
                        p.vy = Math.sin(angle) * speed * 0.3;
                        p.life = 0;
                        p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.explosion / 16.67;
                        p.color = `hsl(${ringHue}, 100%, ${70 + Math.random() * 20}%)`;
                        p.size = (0.8 + Math.random() * 0.5) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * intensityMultiplier;
                        p.active = true;
                        p.isNear = distanceType === 'near';
                        p.isCenter = distanceType === 'center';
                        p.trail = true;
                        p.sparkle = true;
                        p.gravity = 0.08;
                        p.drag = 0.98;
                        p.glowSize = p.size * 2.5 * intensityMultiplier;
                        p.explosionType = 'ring';
                    }
                }, ring * 100);
            }
        }

        function createCrossetteExplosion(x, y, baseHue, distanceType, settings, intensityMultiplier) {
            const clusters = Math.floor((6 + Math.random() * 4) * intensityMultiplier);
            
            for (let i = 0; i < clusters; i++) {
                const angle = (Math.PI * 2 * i) / clusters;
                const clusterSpeed = 4 + Math.random() * 2;
                const clusterX = x + Math.cos(angle) * 30;
                const clusterY = y + Math.sin(angle) * 30;
                
                setTimeout(() => {
                    const particlesInCluster = Math.floor((15 + Math.random() * 10) * intensityMultiplier);
                    
                    for (let j = 0; j < particlesInCluster; j++) {
                        const p = getParticle();
                        if (!p) continue;
                        
                        const subAngle = Math.random() * Math.PI * 2;
                        const subSpeed = (2 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                        
                        p.x = clusterX;
                        p.y = clusterY;
                        p.vx = Math.cos(angle) * clusterSpeed + Math.cos(subAngle) * subSpeed;
                        p.vy = Math.sin(angle) * clusterSpeed + Math.sin(subAngle) * subSpeed;
                        p.life = 0;
                        p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.crossette / 16.67;
                        
                        const clusterHue = (baseHue + i * 45) % 360;
                        p.color = `hsl(${clusterHue}, 100%, ${65 + Math.random() * 25}%)`;
                        
                        p.size = (0.7 + Math.random() * 0.5) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * intensityMultiplier;
                        p.active = true;
                        p.isNear = distanceType === 'near';
                        p.isCenter = distanceType === 'center';
                        p.trail = true;
                        p.glitter = Math.random() > 0.5;
                        p.gravity = 0.11;
                        p.drag = 0.97;
                        p.glowSize = p.size * 2.0 * intensityMultiplier;
                        p.explosionType = 'crossette';
                    }
                }, i * 50);
            }
        }

        function createSpecialExplosion(x, y, baseHue, distanceType, intensityMultiplier) {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.8) return;

            const settings = FIREWORK_CONFIG.distanceSettings[distanceType];
            const numParticles = Math.floor(150 * intensityMultiplier);
            
            const colorCount = 3 + Math.floor(Math.random() * 2);
            const colors = [];
            for (let i = 0; i < colorCount; i++) {
                colors.push(`hsl(${(baseHue + i * (360 / colorCount)) % 360}, 100%, ${65 + Math.random() * 20}%)`);
            }
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (4 + Math.random() * 6) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier * intensityMultiplier;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed * 0.9;
                p.life = 0;
                p.maxLife = FIREWORK_CONFIG.timeSystem.particleLifetime.special / 16.67;
                p.color = colors[Math.floor(Math.random() * colors.length)];
                p.size = (1.0 + Math.random() * 0.8) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * intensityMultiplier;
                p.active = true;
                p.isNear = distanceType === 'near';
                p.isCenter = distanceType === 'center';
                p.trail = true;
                p.sparkle = true;
                p.glitter = true;
                p.gravity = 0.12;
                p.drag = 0.97;
                p.glowSize = p.size * 3.0 * intensityMultiplier;
                p.isSpecial = true;
                p.explosionType = 'special';
            }
            
            setTimeout(() => {
                if (!isRunning) return;
                
                for (let i = 0; i < numParticles * 0.4; i++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 3;
                    
                    p.x = x + (Math.random() - 0.5) * 80;
                    p.y = y + (Math.random() - 0.5) * 80;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = 35 + Math.random() * 25;
                    p.color = `hsl(${(baseHue + 180) % 360}, 100%, 75%)`;
                    p.size = 0.7 + Math.random() * 0.5;
                    p.active = true;
                    p.isNear = distanceType === 'near';
                    p.isCenter = distanceType === 'center';
                    p.sparkle = true;
                    p.gravity = 0.15;
                    p.drag = 0.95;
                    p.glowSize = p.size * 2.0;
                }
            }, 250);
            
            setTimeout(() => {
                if (!isRunning) return;
                
                const ringParticles = 60;
                for (let i = 0; i < ringParticles; i++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const angle = (Math.PI * 2 * i) / ringParticles;
                    const speed = 5 + Math.random() * 2;
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed * 0.2;
                    p.life = 0;
                    p.maxLife = 40 + Math.random() * 20;
                    p.color = '#FFFFFF';
                    p.size = 0.8 + Math.random() * 0.4;
                    p.active = true;
                    p.isNear = distanceType === 'near';
                    p.isCenter = distanceType === 'center';
                    p.sparkle = true;
                    p.gravity = 0.05;
                    p.drag = 0.99;
                    p.glowSize = p.size * 4.0;
                }
            }, 100);
        }

        // ====================== RENDER PARTICLE ======================
        function renderParticle(p, ctx, progress) {
            let alpha = p.isRocket ? (1 - progress ** 1.5) : (1 - progress ** 1.2);
            
            if (climaxSystem.loopSystem.isInClimax) {
                alpha *= 1.1;
            }
            
            if (p.isSpecial) {
                alpha *= 0.8 + 0.3 * Math.sin(progress * 25);
            }
            
            const fadeAlpha = p.fade !== undefined ? p.fade : 1.0;
            alpha *= fadeAlpha;
            
            if (p.glowSize && progress < 0.5 && alpha > 0.3) {
                ctx.shadowBlur = p.glowSize * (1 - progress);
                ctx.shadowColor = p.color;
            }
            
            ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
            ctx.beginPath();
            
            const currentSize = p.size * (p.isRocket ? 1.1 : (1 - progress * 0.3));
            ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
        }

        // ====================== SAO BƒÇNG M√ÄN H√åNH CH·ªú ======================
        let preStartInterval = null;

        function startPreShowShootingStars() {
            const initialCount = isMobile ? 2 : 3;
            createShootingStars(initialCount);
            
            preStartInterval = setInterval(() => {
                if (!showShootingStars || isRunning) {
                    clearInterval(preStartInterval);
                    return;
                }
                const randomCount = isMobile ? (1 + Math.floor(Math.random() * 2)) : (1 + Math.floor(Math.random() * 3));
                createShootingStars(randomCount);
            }, isMobile ? 3000 + Math.random() * 4000 : 2000 + Math.random() * 3000);
        }

        function stopPreShowShootingStars() {
            if (preStartInterval) {
                clearInterval(preStartInterval);
                preStartInterval = null;
            }
            createFinalShootingStars();
        }

        function createFinalShootingStars() {
            if (finalShootingStarsActive) return;
            
            finalShootingStarsActive = true;
            showShootingStars = false;
            
            const finalCount = isMobile ? 6 : 8;
            for (let i = 0; i < finalCount; i++) {
                setTimeout(() => {
                    const batchSize = isMobile ? 1 : 2;
                    createShootingStars(batchSize);
                }, i * (isMobile ? 150 : 200));
            }
            
            setTimeout(() => {
                finalShootingStarsActive = false;
                shootingStars = shootingStars.filter(star => !star.active);
            }, isMobile ? 2500 : 3000);
        }

        // ====================== ANIMATE CH√çNH ======================
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 60;

        function animate(time) {
            if (!isRunning && !showShootingStars) return;
            
            frameCount++;
            if (time - lastFpsUpdate > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = time;
                
                if (fps < 30 && isRunning) {
                    climaxSystem.climaxIntensity *= 0.9;
                }
            }
            
            const targetFrameTime = 1000 / FIREWORK_CONFIG.targetFPS;
            const delta = lastTime === 0 ? 1 : Math.min((time - lastTime) / targetFrameTime, 3.0);
            lastTime = time;

            let clearAlpha = 0.12;
            if (isMobile) clearAlpha = 0.15;
            
            if (isRunning) {
                const climaxIntensity = updateClimaxLoopSystem(time);
                if (climaxIntensity > 2.0) {
                    clearAlpha = Math.max(0.08, clearAlpha * 0.7);
                }
            }
            
            ctx.fillStyle = `rgba(0,0,0,${clearAlpha})`;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            if (shootingStars.length > 0) {
                updateShootingStars(delta);
                renderShootingStars();
            }

            if (isRunning) {
                if (Math.random() < 0.7) {
                    playBassSound();
                }

                ctx.save();
                
                let renderedCount = 0;
                const maxRenderPerFrame = isMobile ? 800 : 1200;
                
                for (let p of particles) {
                    if (!p.active) continue;
                    
                    if (renderedCount >= maxRenderPerFrame) {
                        p.active = false;
                        continue;
                    }
                    
                    p.x += p.vx * delta;
                    p.y += p.vy * delta;

                    if (!p.isRocket) {
                        p.vy += p.gravity * delta * climaxSystem.climaxIntensity;
                        p.vx *= Math.pow(p.drag, delta);
                        p.vy *= Math.pow(p.drag, delta);
                    }

                    p.life += delta;
                    if (p.life >= p.maxLife) {
                        p.active = false;
                        continue;
                    }

                    const progress = p.life / p.maxLife;
                    renderParticle(p, ctx, progress);
                    renderedCount++;
                }
                ctx.restore();

                // T·∫°o ph√°o m·ªõi
                if (time > nextExplosionTime && shouldCreateRocket()) {
                    const interval = getCurrentExplosionInterval();
                    const rocketCount = getRocketCount();
                    
                    for (let i = 0; i < rocketCount; i++) {
                        setTimeout(() => {
                            if (isRunning && shouldCreateRocket()) {
                                createRocket();
                            }
                        }, i * FIREWORK_CONFIG.climaxLoopSystem.burstInterval);
                    }
                    
                    nextExplosionTime = time + interval;
                }

                requestAnimationFrame(animate);
            } else {
                requestAnimationFrame(animate);
            }
        }

        // ====================== KH·ªûI ƒê·ªòNG ======================
        const btn = document.getElementById('startBtn');
        
        async function start() {
            btn.classList.add('clicked');
            stopPreShowShootingStars();
            
            setTimeout(async () => {
                try {
                    await initBackgroundMusic();
                    
                    initAudioSystem();
                    playBackgroundMusic();
                    
                    initCanvas();
                    createParticlePool();
                    initCountdownSystem();

                    if (masterGain) {
                        masterGain.gain.setValueAtTime(0.001, audioCtx?.currentTime || 0);
                        if (audioCtx) {
                            masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 2);
                        }
                    }

                    isRunning = true;
                    startTime = performance.now();
                    lastTime = startTime;
                    
                    // Reset h·ªá th·ªëng
                    climaxSystem.loopSystem.currentCycleStart = 0;
                    climaxSystem.loopSystem.isInClimax = false;
                    climaxSystem.loopSystem.activeClimaxType = null;
                    climaxSystem.loopSystem.particlesCleared = true;
                    climaxSystem.loopSystem.climaxSegmentIndex = -1;
                    climaxSystem.loopSystem.isFirstCycle = true;
                    climaxSystem.loopSystem.allUsedTypes.clear();
                    climaxSystem.loopSystem.usedTypesHistory = [];
                    climaxSystem.loopSystem.currentClimaxTypes = [];
                    climaxSystem.loopSystem.isWaitingForCountdown = false;
                    climaxSystem.loopSystem.shouldShowCountdown = true;
                    
                    nextExplosionTime = startTime + 1000;
                    nextSoundTime = startTime + 1500;

                    requestAnimationFrame(animate);
                    
                } catch (error) {
                    console.error("L·ªói kh·ªüi t·∫°o:", error);
                    initCanvas();
                    createParticlePool();
                    initCountdownSystem();
                    isRunning = true;
                    startTime = performance.now();
                    lastTime = startTime;
                    nextExplosionTime = startTime + 1000;
                    requestAnimationFrame(animate);
                }
            }, 800);
        }

        // ====================== KH·ªûI T·∫†O M√ÄN H√åNH CH·ªú ======================
        function initPreShow() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            initCountdownSystem();
            startPreShowShootingStars();
            requestAnimationFrame(animate);
        }

        // ====================== EVENT LISTENERS ======================
        window.addEventListener('DOMContentLoaded', initPreShow);
        
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            start();
        }, { passive: false });
        
        btn.addEventListener('pointerdown', start);
        
        window.addEventListener('resize', () => {
            initCanvas();
        });
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isRunning = false;
                if (backgroundMusic) {
                    backgroundMusic.pause();
                }
            } else if (startTime > 0) {
                isRunning = true;
                if (backgroundMusic) {
                    playBackgroundMusic();
                }
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
    </script>
</body>
</html>
