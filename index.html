<!DOCTYPE HTML>
<html lang="vi">
<head>
<meta charset="utf-8">
<title>Tr√°i tim d·ªÖ th∆∞∆°ng üíñ</title>
<style>
    html, body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at center, #fff0fa 0%, #ffd9f2 40%, #ffb6e6 100%);
    }

    canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 0 15px #ff99cc);
        animation: pulse 3s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% { filter: drop-shadow(0 0 10px #ff99cc); transform: scale(1); }
        50% { filter: drop-shadow(0 0 25px #ff66cc); transform: scale(1.05); }
    }

    .orbit-text {
        position: absolute;
        font-family: "Poppins", "Comic Sans MS", cursive;
        font-weight: 600;
        font-size: 24px;
        color: #ff66b2;
        text-shadow: 0 0 10px #ffd6eb, 0 0 25px #ffc1e5;
        white-space: nowrap;
        pointer-events: none;
        animation: glow 2.5s ease-in-out infinite;
    }

    @keyframes glow {
        0%, 100% { opacity: 1; text-shadow: 0 0 10px #ffcce6, 0 0 20px #ffb3e6; }
        50% { opacity: 0.7; text-shadow: 0 0 20px #ff99dd, 0 0 35px #ff80cc; }
    }
</style>
</head>
<body>
    <canvas id="pinkboard"></canvas>

    <!-- D√≤ng ch·ªØ xoay quanh tr√°i tim -->
    <div id="orbit1" class="orbit-text">Chu·∫©n b·ªã ƒëi ƒÉn ch∆∞a c√¥ b√© ∆°i</div>
    <div id="orbit2" class="orbit-text">ƒêi ƒÉn l·∫©u c√° nh√≥</div>
    <div id="orbit3" class="orbit-text">S·∫Øp ƒë∆∞·ª£c ƒëi ƒÉn r·ªìi √≥</div>

<script>
/* üíó HI·ªÜU ·ª®NG H·∫†T TR√ÅI TIM */
var settings = {
    particles: { length: 8000, duration: 4, velocity: 80, effect: -1.3, size: 8 },
};

(function() {
    var lastTime = 0, vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    }
})();

var Point = function(x, y) { this.x = x || 0; this.y = y || 0; };
Point.prototype.clone = function() { return new Point(this.x, this.y); };
Point.prototype.length = function(length) {
    if (typeof length == 'undefined')
        return Math.sqrt(this.x * this.x + this.y * this.y);
    this.normalize(); this.x *= length; this.y *= length; return this;
};
Point.prototype.normalize = function() {
    var length = this.length();
    this.x /= length; this.y /= length; return this;
};

var Particle = function() { this.position = new Point(); this.velocity = new Point(); this.acceleration = new Point(); this.age = 0; };
Particle.prototype.initialize = function(x, y, dx, dy) {
    this.position.x = x; this.position.y = y;
    this.velocity.x = dx; this.velocity.y = dy;
    this.acceleration.x = dx * settings.particles.effect;
    this.acceleration.y = dy * settings.particles.effect;
    this.age = 0;
};
Particle.prototype.update = function(deltaTime) {
    this.position.x += this.velocity.x * deltaTime;
    this.position.y += this.velocity.y * deltaTime;
    this.velocity.x += this.acceleration.x * deltaTime;
    this.velocity.y += this.acceleration.y * deltaTime;
    this.age += deltaTime;
};
Particle.prototype.draw = function(context, image) {
    function ease(t){ return (--t)*t*t+1; }
    var size = image.width * ease(this.age / settings.particles.duration);
    context.globalAlpha = 1 - this.age / settings.particles.duration;
    context.drawImage(image, this.position.x - size/2, this.position.y - size/2, size, size);
};

var ParticlePool = function(length) {
    var particles = new Array(length);
    for (var i = 0; i < particles.length; i++) particles[i] = new Particle();
    var firstActive = 0, firstFree = 0, duration = settings.particles.duration;
    return {
        add: function(x, y, dx, dy) {
            particles[firstFree].initialize(x, y, dx, dy);
            firstFree++; if (firstFree == particles.length) firstFree = 0;
            if (firstActive == firstFree) firstActive++;
            if (firstActive == particles.length) firstActive = 0;
        },
        update: function(deltaTime) {
            if (firstActive < firstFree)
                for (i = firstActive; i < firstFree; i++) particles[i].update(deltaTime);
            else {
                for (i = firstActive; i < particles.length; i++) particles[i].update(deltaTime);
                for (i = 0; i < firstFree; i++) particles[i].update(deltaTime);
            }
            while (particles[firstActive].age >= duration && firstActive != firstFree) {
                firstActive++; if (firstActive == particles.length) firstActive = 0;
            }
        },
        draw: function(context, image) {
            if (firstActive < firstFree)
                for (i = firstActive; i < firstFree; i++) particles[i].draw(context, image);
            else {
                for (i = firstActive; i < particles.length; i++) particles[i].draw(context, image);
                for (i = 0; i < firstFree; i++) particles[i].draw(context, image);
            }
        }
    };
};

(function(canvas) {
    var context = canvas.getContext('2d'),
        particles = new ParticlePool(settings.particles.length),
        particleRate = settings.particles.length / settings.particles.duration, time;

    function pointOnHeart(t) {
        return new Point(
            160 * Math.pow(Math.sin(t), 3),
            130 * Math.cos(t) - 50 * Math.cos(2*t) - 20 * Math.cos(3*t) - 10 * Math.cos(4*t) + 25
        );
    }

    var image = (function() {
        var canvas2 = document.createElement('canvas'),
            ctx = canvas2.getContext('2d');
        canvas2.width = settings.particles.size;
        canvas2.height = settings.particles.size;
        function to(t) {
            var p = pointOnHeart(t);
            p.x = settings.particles.size/2 + p.x * settings.particles.size / 350;
            p.y = settings.particles.size/2 - p.y * settings.particles.size / 350;
            return p;
        }
        ctx.beginPath();
        var t = -Math.PI, point = to(t);
        ctx.moveTo(point.x, point.y);
        while (t < Math.PI) { t += 0.01; point = to(t); ctx.lineTo(point.x, point.y); }
        ctx.closePath();
        ctx.fillStyle = '#ff66cc';
        ctx.fill();
        var image = new Image();
        image.src = canvas2.toDataURL();
        return image;
    })();

    function render() {
        requestAnimationFrame(render);
        var newTime = new Date().getTime()/1000, deltaTime = newTime - (time || newTime); time = newTime;
        context.clearRect(0,0,canvas.width,canvas.height);
        var amount = particleRate * deltaTime;
        for (var i=0; i<amount; i++) {
            var pos = pointOnHeart(Math.PI - 2*Math.PI*Math.random());
            var dir = pos.clone().length(settings.particles.velocity);
            particles.add(canvas.width/2 + pos.x, canvas.height/2 - pos.y, dir.x, -dir.y);
        }
        particles.update(deltaTime);
        particles.draw(context, image);
    }

    function onResize() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
    }
    window.onresize = onResize;
    setTimeout(function(){ onResize(); render(); }, 10);
})(document.getElementById('pinkboard'));

/* üí´ CH·ªÆ XOAY V√íNG 3D */
const texts = [
    document.getElementById('orbit1'),
    document.getElementById('orbit2'),
    document.getElementById('orbit3')
];
let angleOffsets = [0, 120, 240];
let radius = 230;
let speed = 0.35;

function animateTexts() {
    let time = Date.now() * 0.001 * speed;
    let centerX = window.innerWidth / 2;
    let centerY = window.innerHeight / 2;
    for (let i = 0; i < texts.length; i++) {
        let angle = time + angleOffsets[i] * Math.PI / 180;
        let depth = Math.sin(angle) * 50;
        let x = centerX + radius * Math.cos(angle);
        let y = centerY + radius * Math.sin(angle) * 0.6;
        texts[i].style.left = (x - 100) + 'px';
        texts[i].style.top = (y - 20 + depth/3) + 'px';
        texts[i].style.transform = `scale(${1 + depth/300}) rotate(${Math.sin(angle)*5}deg)`;
        texts[i].style.zIndex = Math.round(1000 + depth);
        texts[i].style.opacity = 0.7 + depth / 100;
    }
    requestAnimationFrame(animateTexts);
}
animateTexts();
</script>
</body>
</html>
