<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pháo Hoa</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: system-ui, sans-serif;
            color: #fff;
        }
        #canvas {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
        }
        #startBtn {
    position: relative;
    z-index: 10;
    padding: 20px 54px;
    font-size: 30px;
    font-weight: 700;
    color: #111;
    background: linear-gradient(
        135deg,
        #ffffff,
        #f3f3f3
    );
    border: 1px solid rgba(0, 0, 0, 0.08);
    border-radius: 28px;
    cursor: pointer;
    box-shadow:
        0 10px 25px rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    transition:
        transform 0.35s cubic-bezier(.22,1,.36,1),
        box-shadow 0.35s ease,
        background 0.35s ease;
    letter-spacing: 0.5px;
    animation: floatSoft 4s ease-in-out infinite;
    overflow: hidden;
}

#startBtn::after {
    content: "";
    position: absolute;
    top: 0;
    left: -120%;
    width: 120%;
    height: 100%;
    background: linear-gradient(
        120deg,
        transparent,
        rgba(255,255,255,0.7),
        transparent
    );
    transition: left 0.6s ease;
}

#startBtn:hover::after {
    left: 120%;
}

#startBtn:hover {
    transform: translateY(-6px);
    box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 1);
}

#startBtn:active {
    transform: scale(0.92);
    box-shadow:
        0 6px 15px rgba(0, 0, 0, 0.15);
    transition: transform 0.15s ease;
}

#startBtn.clicked {
    animation: fadeOutSmooth 0.9s cubic-bezier(.4,0,.2,1) forwards;
}

.btn-text {
    position: relative;
    z-index: 1;
    color: #111;
}

@keyframes floatSoft {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-8px);
    }
}

@keyframes fadeOutSmooth {
    0% {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
    40% {
        opacity: 0.8;
        transform: scale(1.05) translateY(-16px);
    }
    100% {
        opacity: 0;
        transform: scale(0.7) translateY(60px);
        visibility: hidden;
    }
}

    </style>
</head>
<body>
    <button id="startBtn">
        <span class="btn-text">BẮT ĐẦU</span>
    </button>
    <canvas id="canvas"></canvas>

    <script>
        // CẤU HÌNH ÂM THANH (CHỈ TRẦM)
        const SOUND_CONFIG = {
            masterVolume: 1.3,
            baseInterval: 1600,
            intervalVariation: 1000,
            fadeInTime: 0.2,
            fadeOutTime: 1.2,
            frequencyBlend: {
                min: 30,
                max: 80,
                glideTime: 0.6
            },
            layers: {
                sub: { weight: 1.0, freqRange: [30, 70] },
                deep: { weight: 0.7, freqRange: [20, 45] },
                rumble: { weight: 0.4, freqRange: [100, 300] }
            }
        };

        // CẤU HÌNH PHÁO HOA CHI TIẾT - VỚI HỆ THỐNG CHỐNG LAG
        const FIREWORK_CONFIG = {
            maxParticlesPerExplosion: 120,
            maxIntensity: 2.5,
            
            // Hệ thống điều chỉnh tự động để tránh lag
            adaptiveExplosionRate: {
                baseMinInterval: 1200,    // Khoảng cách cơ bản tối thiểu
                baseMaxInterval: 2300,    // Khoảng cách cơ bản tối đa
                
                // Các ngưỡng điều chỉnh
                thresholds: [
                    { particles: 400, minMultiplier: 1.0, maxMultiplier: 1.0 },   // Bình thường
                    { particles: 700, minMultiplier: 1.5, maxMultiplier: 2.0 },   // Chậm 50%
                    { particles: 1000, minMultiplier: 2.5, maxMultiplier: 3.5 },  // Chậm 150%
                    { particles: 1300, minMultiplier: 4.0, maxMultiplier: 6.0 }   // Chậm 300%
                ],
                
                // Tăng tốc theo thời gian (để bắt đầu nhanh)
                intensityRampUp: {
                    duration: 15000,       // 15 giây đầu tăng tốc
                    startMultiplier: 0.7,  // Bắt đầu ở 70% tốc độ
                    endMultiplier: 1.2     // Lên đến 120% tốc độ
                },
                
                // Dao động theo chu kỳ
                pulseEffect: {
                    enabled: true,
                    period: 20000,         // Chu kỳ 20 giây
                    amplitude: 0.3         // Biên độ 30%
                }
            },
            
            targetFPS: 60,
            maxActiveParticles: 1500,
            particleSizeMultiplier: 0.6,
            rocketSpeedMultiplier: 0.85,
            explosionSpeedMultiplier: 0.75,
            
            // CẤU HÌNH KHOẢNG CÁCH: 30% gần, 70% xa
            distanceDistribution: {
                near: 0.3,
                far: 0.7
            },
            
            distanceSettings: {
                near: {
                    minHeight: 0.15,
                    maxHeight: 0.45,
                    sizeMultiplier: 1.3,
                    speedMultiplier: 1.15,
                    brightnessBoost: 1.2,
                    glowIntensity: 1.4
                },
                far: {
                    minHeight: 0.55,
                    maxHeight: 0.85,
                    sizeMultiplier: 0.75,
                    speedMultiplier: 0.88,
                    brightnessBoost: 0.9,
                    glowIntensity: 0.8
                }
            },
            
            // CÁC LOẠI PHÁO HOA
            explosionTypes: {
                chrysanthemum: 0.25,
                peony: 0.25,
                palm: 0.15,
                willow: 0.15,
                ring: 0.10,
                crossette: 0.10
            }
        };

        // ĐƯỜNG DẪN FILE NHẠC
        const MUSIC_FILE = 'phaobong.mp3';

        let canvas, ctx, audioCtx, masterGain, backgroundMusic;
        let particles = [];
        let particlePoolSize = FIREWORK_CONFIG.maxParticlesPerExplosion * 25;
        let lastTime = 0, startTime = 0;
        let isRunning = false;
        let nextExplosionTime = 0;
        let nextSoundTime = 0;
        let soundSequence = 0;
        let activeSounds = new Set();
        let isMusicLoaded = false;
        let isMusicPlaying = false;
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        // Hệ thống điều chỉnh tốc độ
        let performanceMonitor = {
            lastFrameTime: 0,
            frameCount: 0,
            fps: 60,
            particleCountHistory: [],
            adjustmentMultiplier: 1.0,
            currentIntensity: 1.0,
            timeSinceStart: 0
        };

        // ====================== HỆ THỐNG ĐIỀU CHỈNH TỐC ĐỘ ======================
        function updatePerformanceMonitor(delta, activeParticles) {
            // Cập nhật FPS
            performanceMonitor.frameCount++;
            const now = Date.now();
            if (now - performanceMonitor.lastFrameTime >= 1000) {
                performanceMonitor.fps = Math.min(60, performanceMonitor.frameCount);
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastFrameTime = now;
            }
            
            // Lưu lịch sử số lượng particle
            performanceMonitor.particleCountHistory.push(activeParticles);
            if (performanceMonitor.particleCountHistory.length > 60) {
                performanceMonitor.particleCountHistory.shift();
            }
            
            // Cập nhật thời gian
            performanceMonitor.timeSinceStart += delta / 60;
            
            // Tính toán intensity dựa trên thời gian (tăng tốc dần)
            let timeIntensity = 1.0;
            const rampConfig = FIREWORK_CONFIG.adaptiveExplosionRate.intensityRampUp;
            const timeProgress = Math.min(performanceMonitor.timeSinceStart / (rampConfig.duration / 1000), 1);
            
            if (timeProgress < 1) {
                timeIntensity = rampConfig.startMultiplier + 
                               (rampConfig.endMultiplier - rampConfig.startMultiplier) * 
                               Math.sin(timeProgress * Math.PI * 0.5);
            }
            
            // Thêm hiệu ứng dao động theo chu kỳ
            let pulseIntensity = 1.0;
            const pulseConfig = FIREWORK_CONFIG.adaptiveExplosionRate.pulseEffect;
            if (pulseConfig.enabled) {
                const pulseTime = performanceMonitor.timeSinceStart * 1000;
                pulseIntensity = 1.0 + Math.sin(pulseTime / pulseConfig.period * Math.PI * 2) * pulseConfig.amplitude;
            }
            
            // Tính toán multiplier dựa trên số particle
            let particleMultiplier = 1.0;
            const thresholds = FIREWORK_CONFIG.adaptiveExplosionRate.thresholds;
            
            for (let i = thresholds.length - 1; i >= 0; i--) {
                const threshold = thresholds[i];
                if (activeParticles >= threshold.particles) {
                    particleMultiplier = threshold.minMultiplier;
                    break;
                }
            }
            
            // Kết hợp tất cả các yếu tố
            performanceMonitor.adjustmentMultiplier = particleMultiplier * timeIntensity * pulseIntensity;
            performanceMonitor.currentIntensity = 1.0 / performanceMonitor.adjustmentMultiplier;
            
            return performanceMonitor.adjustmentMultiplier;
        }

        function getAdjustedExplosionInterval() {
            const baseMin = FIREWORK_CONFIG.adaptiveExplosionRate.baseMinInterval;
            const baseMax = FIREWORK_CONFIG.adaptiveExplosionRate.baseMaxInterval;
            
            // Áp dụng multiplier để điều chỉnh khoảng cách
            const adjustedMin = baseMin * performanceMonitor.adjustmentMultiplier;
            const adjustedMax = baseMax * performanceMonitor.adjustmentMultiplier;
            
            return Math.random() * (adjustedMax - adjustedMin) + adjustedMin;
        }

        // ====================== HỆ THỐNG NHẠC NỀN ======================
        function initBackgroundMusic() {
            return new Promise((resolve, reject) => {
                try {
                    backgroundMusic = new Audio();
                    backgroundMusic.src = MUSIC_FILE;
                    backgroundMusic.loop = true;
                    backgroundMusic.volume = 0.7;
                    backgroundMusic.preload = 'auto';
                    
                    backgroundMusic.addEventListener('loadeddata', () => {
                        isMusicLoaded = true;
                        resolve(true);
                    });
                    
                    backgroundMusic.addEventListener('error', (e) => {
                        console.error("❌ Lỗi tải nhạc:", e);
                        reject(new Error("Không thể tải nhạc nền"));
                    });
                    
                    backgroundMusic.load();
                    
                } catch (e) {
                    console.error("❌ Lỗi khởi tạo nhạc:", e);
                    reject(e);
                }
            });
        }

        function playBackgroundMusic() {
            if (!backgroundMusic || !isMusicLoaded) {
                return false;
            }
            
            try {
                backgroundMusic.volume = 0;
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        fadeMusicVolume(0, 0.7, 1.5);
                    }).catch(error => {
                        console.error("❌ Lỗi phát nhạc:", error);
                    });
                }
                
                return true;
            } catch (e) {
                console.error("❌ Lỗi khi phát nhạc:", e);
                return false;
            }
        }

        function fadeMusicVolume(from, to, duration) {
            if (!backgroundMusic) return;
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            function updateVolume() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / (duration * 1000), 1);
                const currentVolume = from + (to - from) * progress;
                
                backgroundMusic.volume = Math.max(0, Math.min(1, currentVolume));
                
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }

        function pauseBackgroundMusic() {
            if (backgroundMusic && isMusicPlaying) {
                backgroundMusic.pause();
                isMusicPlaying = false;
            }
        }

        // ====================== HỆ THỐNG ÂM THANH (CHỈ TRẦM) ======================
        function initAudioSystem() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioCtx.createGain();
                masterGain.gain.value = SOUND_CONFIG.masterVolume;
                
                const compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -20;
                compressor.knee.value = 30;
                compressor.ratio.value = 6;
                compressor.attack.value = 0.03;
                compressor.release.value = 0.3;
                
                const lowShelf = audioCtx.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 150;
                lowShelf.gain.value = 8;
                
                masterGain.connect(lowShelf).connect(compressor).connect(audioCtx.destination);
                
                return true;
            } catch (e) {
                console.log("Audio không được hỗ trợ");
                return false;
            }
        }

        function createBassSound(frequency, type = 'sine', duration = 1.0, volume = 1.0) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.value = frequency;
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + SOUND_CONFIG.fadeInTime);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            const soundId = Symbol();
            activeSounds.add(soundId);
            
            setTimeout(() => {
                activeSounds.delete(soundId);
            }, duration * 1000);
            
            return soundId;
        }

        function createBassGlide(startFreq, endFreq, type = 'sine', duration = 1.2, volume = 0.9) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(endFreq, now + SOUND_CONFIG.frequencyBlend.glideTime);
            
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(volume, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + duration);
            
            return Symbol();
        }

        function createRumbleSound(duration = 0.8, baseFreq = 120, volume = 0.5) {
            const now = audioCtx.currentTime;
            
            for (let i = 0; i < 3; i++) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = baseFreq + (i * 15);
                
                gain.gain.setValueAtTime(0.001, now + (i * 0.05));
                gain.gain.exponentialRampToValueAtTime(volume * (0.7 - i * 0.2), now + (i * 0.05) + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(gain).connect(masterGain);
                osc.start(now + (i * 0.05));
                osc.stop(now + duration);
            }
            
            return Symbol();
        }

        // ====================== CÁC BỘ ÂM THANH BASS (ĐIỀU CHỈNH THEO CƯỜNG ĐỘ) ======================
        function playDeepBass(intensity = 1.0) {
            const baseFreq = 35 + Math.random() * 20;
            const volumeMultiplier = Math.min(1.5, intensity);
            
            createBassSound(
                baseFreq,
                'sine',
                1.4,
                SOUND_CONFIG.layers.sub.weight * volumeMultiplier
            );
            
            setTimeout(() => {
                createBassSound(
                    baseFreq * 0.5,
                    'sine',
                    1.6,
                    SOUND_CONFIG.layers.deep.weight * 0.6 * volumeMultiplier
                );
            }, 200);
            
            setTimeout(() => {
                createRumbleSound(
                    0.6,
                    80 + Math.random() * 40,
                    SOUND_CONFIG.layers.rumble.weight * 0.3 * volumeMultiplier
                );
            }, 150);
        }

        function playBassGlide(intensity = 1.0) {
            const startFreq = 50 + Math.random() * 20;
            const endFreq = startFreq * 0.6;
            const volumeMultiplier = Math.min(1.5, intensity);
            
            createBassGlide(
                startFreq,
                endFreq,
                'sine',
                1.3,
                SOUND_CONFIG.layers.sub.weight * 0.9 * volumeMultiplier
            );
            
            setTimeout(() => {
                createBassSound(
                    startFreq * 1.5,
                    'sine',
                    1.0,
                    SOUND_CONFIG.layers.sub.weight * 0.4 * volumeMultiplier
                );
            }, 300);
        }

        function playDualBass(intensity = 1.0) {
            const freq1 = 40 + Math.random() * 15;
            const freq2 = 55 + Math.random() * 20;
            const volumeMultiplier = Math.min(1.5, intensity);
            
            createBassSound(
                freq1,
                'sine',
                1.2,
                SOUND_CONFIG.layers.sub.weight * 0.8 * volumeMultiplier
            );
            
            setTimeout(() => {
                createBassSound(
                    freq2,
                    'sine',
                    1.1,
                    SOUND_CONFIG.layers.sub.weight * 0.7 * volumeMultiplier
                );
            }, 100);
            
            setTimeout(() => {
                createBassSound(
                    Math.min(freq1, freq2) * 0.4,
                    'sine',
                    1.5,
                    SOUND_CONFIG.layers.deep.weight * 0.5 * volumeMultiplier
                );
            }, 250);
        }

        function playPowerBass(intensity = 1.0) {
            const now = Date.now();
            const timeFactor = Math.sin(now * 0.001) * 0.5 + 0.5;
            const volumeMultiplier = Math.min(1.5, intensity);
            
            const mainFreq = 30 + timeFactor * 20;
            createBassSound(
                mainFreq,
                'sine',
                1.6,
                SOUND_CONFIG.layers.sub.weight * (0.9 + timeFactor * 0.3) * volumeMultiplier
            );
            
            setTimeout(() => {
                createBassSound(
                    mainFreq * 0.75,
                    'sine',
                    1.4,
                    SOUND_CONFIG.layers.deep.weight * 0.6 * volumeMultiplier
                );
                
                createBassSound(
                    mainFreq * 0.6,
                    'sine',
                    1.5,
                    SOUND_CONFIG.layers.deep.weight * 0.4 * volumeMultiplier
                );
            }, 150);
            
            setTimeout(() => {
                createRumbleSound(
                    0.9,
                    60 + Math.random() * 30,
                    SOUND_CONFIG.layers.rumble.weight * 0.5 * volumeMultiplier
                );
            }, 200);
        }

        function playSpecialBassExplosion(intensity = 1.0, isNear = false) {
            const baseFreq = isNear ? 45 + Math.random() * 25 : 35 + Math.random() * 15;
            const duration = isNear ? 1.2 + intensity * 0.3 : 1.4 + intensity * 0.5;
            const volumeMultiplier = Math.min(1.8, intensity);
            
            createBassGlide(
                baseFreq * (isNear ? 1.6 : 1.4),
                baseFreq * 0.5,
                'sine',
                duration,
                SOUND_CONFIG.layers.sub.weight * intensity * (isNear ? 1.5 : 1.3) * volumeMultiplier
            );
            
            setTimeout(() => {
                createBassSound(
                    baseFreq * 0.8,
                    'sine',
                    duration * 0.9,
                    SOUND_CONFIG.layers.deep.weight * intensity * (isNear ? 1.0 : 0.8) * volumeMultiplier
                );
                
                createBassSound(
                    baseFreq * 0.6,
                    'sine',
                    duration * 1.1,
                    SOUND_CONFIG.layers.deep.weight * intensity * (isNear ? 0.8 : 0.6) * volumeMultiplier
                );
            }, 100);
            
            setTimeout(() => {
                createRumbleSound(
                    duration * 0.8,
                    (isNear ? 70 : 50) + Math.random() * 20,
                    SOUND_CONFIG.layers.rumble.weight * intensity * (isNear ? 0.9 : 0.7) * volumeMultiplier
                );
            }, 180);
        }

        function playBassSound(isNear = false) {
            if (!audioCtx || activeSounds.size > 4) return;
            
            soundSequence = (soundSequence + 1) % 4;
            
            const volumeMultiplier = isNear ? 1.2 : 1.0;
            const intensityMultiplier = performanceMonitor.currentIntensity;
            
            switch(soundSequence) {
                case 0:
                    playDeepBass(intensityMultiplier);
                    break;
                case 1:
                    playBassGlide(intensityMultiplier);
                    break;
                case 2:
                    playDualBass(intensityMultiplier);
                    break;
                case 3:
                    playPowerBass(intensityMultiplier);
                    break;
            }
            
            const variation = (Math.random() - 0.5) * SOUND_CONFIG.intervalVariation;
            nextSoundTime = performance.now() + SOUND_CONFIG.baseInterval + variation;
        }

        // ====================== HỆ THỐNG PHÁO HOA VỚI ĐIỀU CHỈNH TỰ ĐỘNG ======================
        
        function createParticlePool() {
            particles = [];
            const poolSize = FIREWORK_CONFIG.maxParticlesPerExplosion * 30;
            
            for (let i = 0; i < poolSize; i++) {
                particles.push({
                    x: 0, y: 0,
                    vx: 0, vy: 0,
                    life: 0, maxLife: 0,
                    color: '#fff',
                    size: 1.0,
                    active: false,
                    isNear: false,
                    isRocket: false,
                    
                    // Thuộc tính chi tiết
                    trail: false,
                    sparkle: false,
                    glitter: false,
                    fade: 1.0,
                    rotation: 0,
                    rotationSpeed: 0,
                    gravity: 0.1,
                    drag: 0.98,
                    
                    // Thuộc tính hiệu ứng
                    glowSize: 0,
                    coreSize: 0,
                    trailLength: 0,
                    trailColor: '',
                    
                    // Thuộc tính cho crossette
                    isCrossette: false,
                    crossetteTimer: 0,
                    hasExploded: false,
                    
                    // Thuộc tính cho willow/palm
                    isWillow: false,
                    trailParticles: []
                });
            }
        }

        function getParticle() {
            for (let p of particles) {
                if (!p.active) return p;
            }
            
            let oldestParticle = null;
            let oldestLife = 0;
            for (let p of particles) {
                if (p.active) {
                    const lifeRatio = p.life / p.maxLife;
                    if (lifeRatio > oldestLife) {
                        oldestLife = lifeRatio;
                        oldestParticle = p;
                    }
                }
            }
            
            if (oldestParticle && oldestLife > 0.85) {
                oldestParticle.active = false;
                return oldestParticle;
            }
            
            return null;
        }

        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function countActiveParticles() {
            let count = 0;
            for (let p of particles) {
                if (p.active) count++;
            }
            return count;
        }

        // Tạo rocket với điều chỉnh theo cường độ
        function createRocket() {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.9) return;

            const isNear = Math.random() < FIREWORK_CONFIG.distanceDistribution.near;
            const settings = FIREWORK_CONFIG.distanceSettings[isNear ? 'near' : 'far'];
            
            // Điều chỉnh số lượng particle theo cường độ hiện tại
            const intensityMultiplier = Math.min(1.5, performanceMonitor.currentIntensity);
            const particleMultiplier = isNear ? 1.0 : 0.8;
            
            const x = Math.random() * window.innerWidth;
            const yStart = window.innerHeight;
            const hue = Math.random() * 360;

            // Tạo rocket chính
            const p = getParticle();
            if (p) {
                p.x = x;
                p.y = yStart;
                p.vx = (Math.random() - 0.5) * 1.5;
                p.vy = -(13 + Math.random() * 7) * FIREWORK_CONFIG.rocketSpeedMultiplier * settings.speedMultiplier;
                p.life = 0;
                p.maxLife = 55 + Math.random() * 25;
                p.color = `hsl(${hue}, 100%, ${isNear ? 85 : 75}%)`;
                p.size = (1.8 + Math.random() * 1.0) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * intensityMultiplier;
                p.active = true;
                p.isRocket = true;
                p.isNear = isNear;
                p.trailHue = hue;
                p.glowSize = p.size * 2.5 * intensityMultiplier;
                p.trailLength = (isNear ? 8 : 6) * intensityMultiplier;
            }

            // Tạo dấu vết khói cho rocket (giảm tần suất khi cường độ thấp)
            const trailFrequency = Math.max(50, 100 / intensityMultiplier); // Chậm lại khi nhiều particle
            let trailInterval = setInterval(() => {
                if (!isRunning || !p || !p.active) {
                    clearInterval(trailInterval);
                    return;
                }
                
                // Giảm số lượng trail khi FPS thấp
                if (Math.random() > 0.7 * intensityMultiplier) return;
                
                const trail = getParticle();
                if (trail) {
                    trail.x = p.x + (Math.random() - 0.5) * 2;
                    trail.y = p.y + (Math.random() - 0.5) * 2;
                    trail.vx = p.vx * 0.2 + (Math.random() - 0.5) * 0.5;
                    trail.vy = p.vy * 0.1 + Math.random() * 1;
                    trail.life = 0;
                    trail.maxLife = 15 + Math.random() * 15;
                    trail.color = `hsl(${hue}, 80%, 60%)`;
                    trail.size = p.size * 0.5;
                    trail.active = true;
                    trail.fade = 0.7;
                    trail.drag = 0.95;
                }
            }, trailFrequency);

            // Lên lịch nổ
            setTimeout(() => {
                if (!isRunning) return;
                clearInterval(trailInterval);
                
                const minHeight = settings.minHeight * window.innerHeight;
                const maxHeight = settings.maxHeight * window.innerHeight;
                const yExplode = minHeight + Math.random() * (maxHeight - minHeight);
                
                // Chọn loại pháo hoa
                const rand = Math.random();
                let explosionType;
                let cumulative = 0;
                
                for (let [type, probability] of Object.entries(FIREWORK_CONFIG.explosionTypes)) {
                    cumulative += probability;
                    if (rand <= cumulative) {
                        explosionType = type;
                        break;
                    }
                }
                
                createExplosion(x, yExplode, hue, isNear, explosionType, intensityMultiplier);
                
                if (Math.random() > 0.65 && intensityMultiplier > 0.7) {
                    playSpecialBassExplosion(1 + Math.random() * 0.6 * intensityMultiplier, isNear);
                }
            }, (isNear ? 850 : 1150) + Math.random() * 700 / intensityMultiplier);
        }

        // Hàm tạo vụ nổ với điều chỉnh số lượng particle
        function createExplosion(x, y, baseHue, isNear, type = 'peony', intensityMultiplier = 1.0) {
            const activeCount = countActiveParticles();
            if (activeCount > FIREWORK_CONFIG.maxActiveParticles * 0.85) return;

            const settings = FIREWORK_CONFIG.distanceSettings[isNear ? 'near' : 'far'];
            
            // Giảm số lượng particle khi cường độ thấp
            const particleCountMultiplier = Math.min(1.0, intensityMultiplier);
            
            switch(type) {
                case 'chrysanthemum':
                    createChrysanthemumExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier);
                    break;
                case 'peony':
                    createPeonyExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier);
                    break;
                case 'palm':
                    createPalmExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier);
                    break;
                case 'willow':
                    createWillowExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier);
                    break;
                case 'ring':
                    createRingExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier);
                    break;
                case 'crossette':
                    createCrossetteExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier);
                    break;
                default:
                    createPeonyExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier);
            }
        }

        // Các hàm tạo explosion với parameter particleCountMultiplier
        function createChrysanthemumExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier = 1.0) {
            const rays = Math.floor((25 + Math.random() * 20) * particleCountMultiplier);
            const particlesPerRay = Math.floor((8 + Math.random() * 6) * particleCountMultiplier);
            
            for (let i = 0; i < rays; i++) {
                const angle = (Math.PI * 2 * i) / rays;
                
                for (let j = 0; j < particlesPerRay; j++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const speed = (6 + j * 0.8 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0;
                    p.maxLife = (isNear ? 75 : 65) + Math.random() * 40;
                    
                    const hueShift = (Math.random() - 0.5) * 30;
                    const brightness = (isNear ? 65 : 55) + Math.random() * 25;
                    p.color = `hsl(${baseHue + hueShift}, 100%, ${brightness}%)`;
                    
                    p.size = (0.9 + Math.random() * 0.8) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * particleCountMultiplier;
                    p.active = true;
                    p.isNear = isNear;
                    p.trail = true;
                    p.trailLength = (isNear ? 4 : 3) + Math.random() * 3;
                    p.sparkle = j % 3 === 0;
                    p.gravity = 0.08;
                    p.drag = 0.985;
                    p.glowSize = p.size * (isNear ? 2.2 : 1.8);
                }
            }
        }

        function createPeonyExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier = 1.0) {
            const numParticles = Math.floor(((isNear ? 100 : 80) + Math.random() * 60) * particleCountMultiplier);
            
            for (let i = 0; i < numParticles * 0.4; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (3 + Math.random() * 4) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = (isNear ? 70 : 60) + Math.random() * 50;
                p.color = `hsl(${baseHue}, 100%, ${(isNear ? 75 : 65) + Math.random() * 20}%)`;
                p.size = (1.2 + Math.random() * 0.8) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * particleCountMultiplier;
                p.active = true;
                p.isNear = isNear;
                p.trail = true;
                p.glitter = Math.random() > 0.6;
                p.gravity = 0.09;
                p.drag = 0.98;
                p.glowSize = p.size * (isNear ? 2.5 : 2.0);
            }
            
            for (let i = 0; i < numParticles * 0.6; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = (5 + Math.random() * 6) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed * 0.9;
                p.life = 0;
                p.maxLife = (isNear ? 65 : 55) + Math.random() * 55;
                
                const hueShift = (Math.random() - 0.5) * 60;
                p.color = `hsl(${baseHue + hueShift}, ${85 + Math.random() * 15}%, ${(isNear ? 65 : 55) + Math.random() * 30}%)`;
                p.size = (0.8 + Math.random() * 1.0) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * particleCountMultiplier;
                p.active = true;
                p.isNear = isNear;
                p.trail = true;
                p.sparkle = Math.random() > 0.5;
                p.gravity = 0.1;
                p.drag = 0.975;
                p.glowSize = p.size * (isNear ? 2.0 : 1.6);
            }
        }

        function createPalmExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier = 1.0) {
            const numStrands = Math.floor((20 + Math.random() * 15) * particleCountMultiplier);
            const particlesPerStrand = Math.floor((12 + Math.random() * 8) * particleCountMultiplier);
            
            for (let i = 0; i < numStrands; i++) {
                const angle = (Math.PI * 2 * i) / numStrands + (Math.random() - 0.5) * 0.3;
                const baseSpeed = (4 + Math.random() * 3) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                
                for (let j = 0; j < particlesPerStrand; j++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const speed = baseSpeed * (1 - j * 0.05);
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle) * speed * 0.8;
                    p.vy = Math.sin(angle) * speed * 0.3 - 2;
                    p.life = 0;
                    p.maxLife = (isNear ? 90 : 80) + Math.random() * 60;
                    
                    const goldShift = Math.random() * 40 - 20;
                    p.color = `hsl(${45 + goldShift}, 100%, ${(isNear ? 60 : 50) + Math.random() * 30}%)`;
                    p.size = (0.7 + Math.random() * 0.6) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * particleCountMultiplier;
                    p.active = true;
                    p.isNear = isNear;
                    p.trail = true;
                    p.trailLength = (isNear ? 6 : 5) + Math.random() * 4;
                    p.gravity = 0.15 + Math.random() * 0.05;
                    p.drag = 0.96;
                    p.isWillow = true;
                }
            }
        }

        function createWillowExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier = 1.0) {
            const numBranches = Math.floor((18 + Math.random() * 12) * particleCountMultiplier);
            const particlesPerBranch = Math.floor((15 + Math.random() * 10) * particleCountMultiplier);
            
            for (let i = 0; i < numBranches; i++) {
                const angle = (Math.PI * 2 * i) / numBranches;
                const baseSpeed = (3.5 + Math.random() * 2.5) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                
                for (let j = 0; j < particlesPerBranch; j++) {
                    const p = getParticle();
                    if (!p) continue;
                    
                    const speed = baseSpeed * (1 - j * 0.04);
                    const angleOffset = (Math.random() - 0.5) * 0.4;
                    
                    p.x = x;
                    p.y = y;
                    p.vx = Math.cos(angle + angleOffset) * speed;
                    p.vy = Math.sin(angle + angleOffset) * speed * 0.6;
                    p.life = 0;
                    p.maxLife = (isNear ? 100 : 90) + Math.random() * 70;
                    
                    p.color = `hsl(${baseHue + (Math.random() - 0.5) * 40}, 90%, ${(isNear ? 55 : 45) + Math.random() * 25}%)`;
                    p.size = (0.6 + Math.random() * 0.5) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * particleCountMultiplier;
                    p.active = true;
                    p.isNear = isNear;
                    p.trail = true;
                    p.trailLength = (isNear ? 7 : 6) + Math.random() * 5;
                    p.gravity = 0.12 + Math.random() * 0.03;
                    p.drag = 0.97;
                    p.isWillow = true;
                    p.sparkle = j % 4 === 0;
                }
            }
        }

        function createRingExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier = 1.0) {
            const numRings = 2 + Math.floor(Math.random() * 2);
            
            for (let ring = 0; ring < numRings; ring++) {
                const particlesInRing = Math.floor((60 + Math.random() * 40) * particleCountMultiplier);
                const ringDelay = ring * 100;
                const ringSpeed = (5 + ring * 1.5 + Math.random() * 2) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                
                setTimeout(() => {
                    if (!isRunning) return;
                    
                    for (let i = 0; i < particlesInRing; i++) {
                        const p = getParticle();
                        if (!p) continue;
                        
                        const angle = (Math.PI * 2 * i) / particlesInRing;
                        
                        p.x = x;
                        p.y = y;
                        p.vx = Math.cos(angle) * ringSpeed;
                        p.vy = Math.sin(angle) * ringSpeed;
                        p.life = 0;
                        p.maxLife = (isNear ? 60 : 50) + Math.random() * 40;
                        
                        const hueShift = ring * 60 + (Math.random() - 0.5) * 20;
                        p.color = `hsl(${baseHue + hueShift}, 100%, ${(isNear ? 70 : 60) + Math.random() * 20}%)`;
                        p.size = (0.9 + Math.random() * 0.6) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * particleCountMultiplier;
                        p.active = true;
                        p.isNear = isNear;
                        p.trail = true;
                        p.sparkle = i % 3 === 0;
                        p.gravity = 0.08;
                        p.drag = 0.99;
                        p.glowSize = p.size * (isNear ? 2.3 : 1.9);
                    }
                }, ringDelay);
            }
        }

        function createCrossetteExplosion(x, y, baseHue, isNear, settings, particleCountMultiplier = 1.0) {
            const numInitialBursts = Math.floor((8 + Math.random() * 6) * particleCountMultiplier);
            
            for (let i = 0; i < numInitialBursts; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = (Math.PI * 2 * i) / numInitialBursts;
                const speed = (7 + Math.random() * 3) * FIREWORK_CONFIG.explosionSpeedMultiplier * settings.speedMultiplier;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = (isNear ? 80 : 70) + Math.random() * 50;
                p.color = `hsl(${baseHue}, 100%, ${(isNear ? 70 : 60) + Math.random() * 20}%)`;
                p.size = (1.1 + Math.random() * 0.7) * FIREWORK_CONFIG.particleSizeMultiplier * settings.sizeMultiplier * particleCountMultiplier;
                p.active = true;
                p.isNear = isNear;
                p.trail = true;
                p.isCrossette = true;
                p.crossetteTimer = 15 + Math.random() * 10;
                p.hasExploded = false;
                p.gravity = 0.07;
                p.drag = 0.98;
                p.glowSize = p.size * (isNear ? 2.5 : 2.0);
                p.baseHue = baseHue;
                p.baseX = x;
                p.baseY = y;
            }
        }

        // Mini explosion cho crossette
        function createMiniExplosion(x, y, baseHue, isNear, numParticles = 8, particleCountMultiplier = 1.0) {
            numParticles = Math.floor(numParticles * particleCountMultiplier);
            
            for (let i = 0; i < numParticles; i++) {
                const p = getParticle();
                if (!p) continue;
                
                const angle = (Math.PI * 2 * i) / numParticles + (Math.random() - 0.5) * 0.5;
                const speed = 3 + Math.random() * 2;
                
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.life = 0;
                p.maxLife = 30 + Math.random() * 20;
                p.color = `hsl(${baseHue + (Math.random() - 0.5) * 60}, 100%, ${60 + Math.random() * 30}%)`;
                p.size = 0.5 * FIREWORK_CONFIG.particleSizeMultiplier * particleCountMultiplier;
                p.active = true;
                p.isNear = isNear;
                p.sparkle = true;
                p.gravity = 0.1;
                p.drag = 0.96;
            }
        }

        // Render particles với hiệu ứng chi tiết
        function renderParticle(p, ctx, progress, delta) {
            let alpha = p.isRocket ? (1 - progress ** 1.8) : (1 - progress ** 1.4);
            
            // Xử lý crossette
            if (p.isCrossette && !p.hasExploded && p.life > p.crossetteTimer) {
                p.hasExploded = true;
                createMiniExplosion(p.x, p.y, p.baseHue, p.isNear, 8, performanceMonitor.currentIntensity);
            }
            
            // Hiệu ứng sparkle/glitter
            if (p.sparkle && !p.isRocket) {
                alpha *= 0.5 + 0.5 * Math.sin(progress * 30 + p.life * 0.5);
            }
            
            if (p.glitter && !p.isRocket && progress > 0.3) {
                alpha *= 0.3 + 0.7 * Math.sin(progress * 50);
            }
            
            // Điều chỉnh độ sáng theo khoảng cách
            if (p.isNear && !p.isRocket) {
                alpha *= 1.15;
            }
            
            const fadeAlpha = p.fade !== undefined ? p.fade : 1.0;
            alpha *= fadeAlpha;
            
            // Vẽ glow (hào quang)
            if (p.glowSize && progress < 0.6) {
                const glowAlpha = alpha * (1 - progress * 1.2) * 0.6;
                ctx.shadowBlur = p.glowSize * (1 - progress * 0.5);
                ctx.shadowColor = p.color.replace(')', `, ${glowAlpha})`).replace('hsl', 'hsla');
            }
            
            // Vẽ trail (đuôi sáng)
            if (p.trailLength && progress < 0.5 && !p.isRocket) {
                ctx.shadowBlur = p.trailLength * (1 - progress * 1.5);
                ctx.shadowColor = p.color;
            } else if (p.trail && !p.isRocket && progress < 0.4) {
                ctx.shadowBlur = (p.isNear ? 5 : 4) + Math.random() * 3;
                ctx.shadowColor = p.color;
            }
            
            // Vẽ particle
            ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
            ctx.beginPath();
            
            const currentSize = p.size * (p.isRocket ? 1.2 : (1 - progress * 0.4));
            ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        // HÀM ANIMATE CHÍNH VỚI HỆ THỐNG ĐIỀU CHỈNH
        function animate(time) {
            if (!isRunning) return;
            requestAnimationFrame(animate);
            
            const delta = lastTime === 0 ? 1 : Math.min((time - lastTime) / (1000 / FIREWORK_CONFIG.targetFPS), 2);
            lastTime = time;

            const activeParticles = countActiveParticles();
            
            // Cập nhật hệ thống điều chỉnh
            updatePerformanceMonitor(delta, activeParticles);
            
            // Phát âm thanh với điều chỉnh theo cường độ
            if (time > nextSoundTime) {
                const isNear = Math.random() < FIREWORK_CONFIG.distanceDistribution.near;
                playBassSound(isNear);
            }

            // Xóa màn hình với độ trong suốt thay đổi
            const clearAlpha = performanceMonitor.fps < 45 ? 0.15 : 0.1;
            ctx.fillStyle = `rgba(0,0,0,${clearAlpha})`;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            // Render particles với tối ưu hóa
            ctx.save();
            let renderedCount = 0;
            const maxRenderPerFrame = performanceMonitor.fps < 40 ? 800 : 1200;
            
            for (let p of particles) {
                if (!p.active) continue;
                
                // Giới hạn số lượng particle render mỗi frame nếu FPS thấp
                if (renderedCount > maxRenderPerFrame) break;
                renderedCount++;

                // Áp dụng vận tốc
                p.x += p.vx * delta;
                p.y += p.vy * delta;

                // Áp dụng trọng lực và lực cản
                if (!p.isRocket) {
                    const gravity = p.gravity !== undefined ? p.gravity : 0.10;
                    const drag = p.drag !== undefined ? p.drag : 0.98;
                    
                    p.vy += gravity * delta;
                    p.vx *= drag;
                    p.vy *= drag;
                }

                p.life += delta;
                if (p.life >= p.maxLife) {
                    p.active = false;
                    continue;
                }

                const progress = p.life / p.maxLife;
                renderParticle(p, ctx, progress, delta);
            }
            ctx.restore();

            // Tạo pháo mới với điều chỉnh tự động
            if (time > nextExplosionTime) {
                // Tính toán khoảng cách dựa trên performance
                const interval = getAdjustedExplosionInterval();
                
                // Tạo rocket mới
                createRocket();
                
                // Lên lịch cho lần tiếp theo
                nextExplosionTime = time + interval;
            }
        }

        // ====================== KHỞI ĐỘNG VỚI HIỆU ỨNG NÚT ======================
        const btn = document.getElementById('startBtn');
        
        async function start() {
            // Thêm hiệu ứng nhấn
            btn.classList.add('clicked');
            
            // Đợi hiệu ứng hoàn thành
            setTimeout(async () => {
                try {
                    await initBackgroundMusic();
                    
                    if (!initAudioSystem()) {
                        alert("Trình duyệt không hỗ trợ Web Audio API. Vui lòng dùng Chrome/Firefox/Safari mới nhất.");
                        btn.classList.remove('clicked');
                        btn.style.visibility = 'visible';
                        return;
                    }
                    
                    playBackgroundMusic();
                    
                    initCanvas();
                    createParticlePool();

                    if (masterGain) {
                        masterGain.gain.setValueAtTime(0.001, audioCtx.currentTime);
                        masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 2.5);
                    }

                    setTimeout(() => {
                        playPowerBass(1.2);
                    }, 500);

                    isRunning = true;
                    startTime = performance.now();
                    lastTime = startTime;
                    
                    // Sử dụng hệ thống điều chỉnh để thiết lập thời gian đầu
                    nextExplosionTime = startTime + getAdjustedExplosionInterval() * 0.7;
                    nextSoundTime = startTime + 1200;

                    requestAnimationFrame(animate);
                    
                } catch (error) {
                    console.error("Lỗi khởi tạo:", error);
                    alert("Có lỗi xảy ra khi khởi tạo. Vui lòng thử lại.");
                    btn.classList.remove('clicked');
                    btn.style.visibility = 'visible';
                }
            }, 800);
        }

        // ====================== EVENT LISTENERS ======================
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            start();
        }, { passive: false });
        
        btn.addEventListener('pointerdown', start);
        
        window.addEventListener('resize', () => {
            if (isRunning) initCanvas();
        });
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isRunning = false;
                pauseBackgroundMusic();
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                }
            } else if (startTime > 0) {
                isRunning = true;
                if (masterGain) {
                    masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                    masterGain.gain.exponentialRampToValueAtTime(SOUND_CONFIG.masterVolume, audioCtx.currentTime + 0.5);
                }
                if (backgroundMusic && !isMusicPlaying) {
                    playBackgroundMusic();
                }
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
        
        window.addEventListener('beforeunload', () => {
            pauseBackgroundMusic();
        });
    </script>
</body>
</html>
